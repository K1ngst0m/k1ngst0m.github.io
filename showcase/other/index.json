[{"content":"游戏引擎的主要工作是控制场景, 角色在场景中的互动, 主要包括三个部分:\n数学引擎(Math Engine)  数学引擎包括了所有的线性代数和矩阵操作, 是首先要开发的引擎 其中最基础的两个操作: 矩阵(Matrix), 向量(Vector), 用于定义场景相关数据, 物体的空间信息等 向量操作: 加减法(Addition), 向量点乘(Dot Product), 叉乘(Cross Product)等 矩阵操作: 矩阵变换(Transformation), 转置(Transpose), 逆(Inverse)等 对于物体的旋转, 可以使用矩阵, 或是更加直观的四元数(Quaternion)或欧拉角(Euler Angle)  渲染引擎(Rendering Engine)   渲染引擎的主要工作是将场景显示到屏幕上, 需要 GPU 的支持\n  程序与 GPU 的交互需要使用图形 API, 图形 API 的主要任务是将 CPU 数据送到 GPU 中处理, 常见的图形 API 有OpenGL, DirectX, Vulkan\n  引擎会渲染不同类型的对象(game object), 主要有: 3D 模型, 图片, 文字, 精灵图(Sprites)等, 这些对象需要包含的渲染信息有:\n 顶点位置(Vertex Position) UV 坐标(UV Coordinates) 法向量(Normals) 纹理(Textures)    通过 rendering manager 管理不同类型的对象, 将这些对象输入到缓冲区, 再放入渲染管线中, 渲染信息通过着色器(shader)控制\n  Entity Manager 使用一个Entity Manager追踪和管理游戏里所有的激活的entity, 通常使用一个能够快速遍历节点的数据结构, 如场景图(Scene Graph)(推荐),平衡二叉树(AVL), 红黑树(Red-Black)等\n游戏循环(Game Loop) 设置一个主循环来持续渲染(Render)和更新(Update)每个场景中的物体\n更新(Update) 通过Entity Manager提供渲染对象所需要的信息, 使用Math Engine来设置物体空间属性(坐标, 坐标空间等), 通过矩阵和向量操作来移动和旋转物体\n渲染(Render) 通过Rendering Manager控制Game Loop的另一部分, 如 3D 角色, 精灵图, 天空盒等\n物理引擎(Physics Engine)  物理引擎根据输入的场景信息, 决定entity的位置和速度 通过模拟物理学中的力(force), 整合entity受到的运动方程(equation of motion)来实现, 常用的整合方法有Runge-Kutta Method(RK4), Verlet Method, Euler Method 通常entity会受到一些永恒的力, 如重力来控制物体下落  参考资料:\n https://www.haroldserrano.com/blog/how-do-i-build-a-game-engine https://www.haroldserrano.com/blog/how-to-develop-a-rendering-engine-an-overview https://www.haroldserrano.com/blog/how-a-physics-engine-works-an-overview  ","description":"游戏引擎结构和工作流程","id":6,"section":"posts","tags":["cg"],"title":"游戏引擎工作流程","uri":"https://npchitman.com/posts/game_engine/"},{"content":"透明渲染算法 常见的透明渲染算法有两种\nScreen-Door Transparency  阿尔法覆盖(alpha to coverage) 使用棋盘格填充模式来绘制多边形 每隔 1 个像素绘制一点来绘制会使后面的物体部分可见, 由于屏幕上像素比较紧凑, 不会露馅 优点: 可以任意时间和顺序绘制物体, 不需要特殊的硬件支持 缺点: 透明效果在 50%的时候最好, 不易于控制, 屏幕中的每个区域只能绘制一个透明物体  Alpha 混合 (Alpha Blending)  Alpha 值用于表示透明度, 用来混合源像素和目标像素 从渲染管线接收像素的 RGBA + z-buffer 值来绘制  透明排序   渲染透明物体时, 需要开启深度测试, 对重合的部分进行混合(blender)运算, 深度写入需要关闭, 若是开启会导致后面的物体不可见\n  需要将物体排序才能正确地绘制到场景中:\n 绘制所有不透明的物体: 按照深度缓冲正常绘制 对所有透明物体排序: 从远到近 按顺序绘制所有透明的物体    Early-Z:\n 提前做深度测试(在片段着色器之前) 通常由硬件实现 Alpha 测试和深度写入可能会使 early-z 失效    深度缓冲 (Z-Buffer)  主流选择 深度缓冲可在硬件或软件中完成, 是可见性问题的一个解决方案 每个像素只存储一个对象, 重叠时透明对象后边的可见对象不能存储, 无法显示 使用 A-buffer 解决该问题, A-buffer 具有深度像素(deep pixel), 可以在单个像素中存储一系列呈现在所有对象之后被解析为单个像素的多个片段  画家算法 / 优先填充算法 (Painter\u0026rsquo;s Algorithm)  先绘制远的场景, 再绘制近的场景覆盖 首先将场景中多边形根据深度进行排序, 按照顺序进行描绘 较复杂的场景(三角形覆盖)无法解决  加权平均算法 (Weighted Average)  使用简单的透明混合公式来实现无序透明渲染  深度剥离算法 (Depth Peeling)  对深度值进行排序 标准深度检测, 将 Z 值最小的点输出到屏幕上 进行多遍渲染, 每个顶点深度值与之前的深度值进行比较, 凡是小于等于第一遍得到的 z 值, 将其剥离  ","description":"透明物体渲染及排序算法","id":7,"section":"posts","tags":["cg"],"title":"透明渲染与排序","uri":"https://npchitman.com/posts/transparency/"},{"content":"游戏渲染优化的方向: 更高的 FPS, 更高的分辨率, 能够渲染更多的物体, 更真实的场景, 实现更高的复杂度\n游戏开发中的渲染加速算法 常用空间数据结构(Spatial Data Structures) 空间数据结构是将几何体组织在 N 维空间的一系列数据结构, 可以用于很多实时渲染的加速查询, 如:\n 场景管理 裁剪算法 相交测试 光线追踪 碰撞检测等  空间数据结构的组织通常是层次结构(最顶层嵌套递归包含之下的层次), 访问复杂度可以达到 O(logn), 但是构造开销较大, 通常需要作为一个预处理的过程来完成\n常见的空间数据结构有:\n  层次包围盒(BVH, Bounding Volume Hierarchies)\n 利用体积略大的几何特征简单的包围盒近似描述复杂的几何对象, 从而只需对包围盒重叠的对象进行进一步相交测试 通过构造树状层次结构, 可以越来越逼近对象的几何模型, 直至几乎完全获得对象几何特征 层次包围体通常用于层次视锥裁剪, 场景及层次树状结构进行组织: 根节点(root), 内部节点(internal), 叶子节点(leaves)包含需渲染的几何体    二叉空间分割树(BSP, Binary Space Partition Trees)\n 基于空间细分(Space Subdivision)的数据结构, 可任意细分 BSP 递归地将空间使用超平面划分为凸面体的几何, 使用 BSP 树实现:  每个节点表示一个有向超平面, 左子树为前向(front), 右子树为背向(back) 如果使用一种特定方式遍历, 树的内容可以从任意角度进行前后排序: 可以近似轴对齐, 精确对齐多边形 BSP   类似于画家算法, BSP 方便将表面从后往前渲染出来, 适用于场景固定不变, 仅视点移动的情况 BSP 树有两大类别: 轴对齐(Axis-Aligned)和多边形对齐(Polygon-Aligned)    八叉树(Octrees):\n 基于空间细分, 均匀分割 每个节点表示正方体的体积元素 每个节点有八个子节点加起来等于父节点的体积, 中心点为节点的分叉中心 这种分割方式可以得到比较规则的结构, 使得查询更加高效 松散八叉树(Loose Octrees): 基本思想和普通八叉树一样, 每个长方体大小选中比较宽松, 使用松散八叉树更加灵活(一个物体处于边缘时)    四叉树(QuadTree):\n 相对于八叉树, 将二位正方形空间分割成四个小正方形    kd 树(k-dimensional tree)\n 对 k 维空间中的实例点进行存储以便快速检索的树形结构 主要应用于多维空间关键字搜索    场景图(Scene Graphs)\n 存储场景中复杂多样的几何体(几何图形, 动画, 可见性, 其他元素的控制) 可以通过纹理, 变换, 细节层次, 渲染状态(如材质属性), 光源等合适的内容进行扩充, 以一颗深度优先遍历来渲染整个场景的树来表示    裁剪技术 (culling) 裁剪操作可以发生在渲染管线的任意阶段, 可以预处理, 通过硬件实现, 在 CPU 中配置, 裁剪通常可以使用几何计算来实现, 也可以使用帧缓冲中的内容, 理想的裁剪算法预期是只发送图元中通过管线的精确可见集(Exact Visible Set, EVS)\n  背面裁剪(Backface Culling)\n 对于不透明的物体, 将背向视点的物体删除, 无需光栅化 聚集背面裁剪(Clustered Backface Culling): 一次性对于一组物体进行背面裁剪 确定多边形是否背向的方法: 在屏幕或视点空间中, 通过判断顶点排列方向(顺时针或逆时针, 向量叉乘)    视锥裁剪(View Frustum Culling), 层次视锥裁剪(Hierarchical View Frustum Culling)\n 将视锥之外的多边形删除 计算在 CPU 上进行, 排除的物体不需要通过管线中的几何和光栅化阶段 利用空间数据结构可以分层进行裁剪    遮挡剔除(Occlusion Culling)\n 将被其他物体遮挡的物体进行删除 算法两种主要形式: 基于点的遮挡裁剪, 基于单元的遮挡裁剪 常见的遮挡剔除算法(Occlusion Culling Algorithm):  硬件遮挡查询(Hardware Occlusion Queries): 通过硬件查询一组多边形是否可见(通常是复杂物体或包围体), 使用 z-buffer 层次 Z 缓冲(Hierarchical Z-buffering): 用八叉树来维护场景模型, 将画面的 z-buffer 作为图像金字塔(Z-pyramid), 作为算法的遮挡表示 遮挡地平线(Occlusion Horizons) 遮挡物收缩(Occluder Shrinking)      入口裁剪(Portal Culling):\n 室内场景通过每个入口(门或窗户等)进行视锥裁剪, 遍历入口时减小视锥    细节裁剪(Detail Culling):\n 牺牲质量换取速度 当视点处于运动时, 微小细节对于渲染出的图像贡献甚微, 减小这些物体的细节    层次细节技术(LOD, Level of Detail)  LOD 切换技术:  Discrete Geometry LODs Blend LODs Alpha LODs CLODs and Geomorphic LODs   LOD 选取技术:  Range-Based Project Area-Based Hysteresis    大型模型的渲染(Large Model Rendering)  点渲染(Point Rendering)  渲染管线优化方法 优化的过程可以归纳为以下基本的确认和优化的循环:\n 定位瓶颈: 对于管线的每个阶段, 若改变负载或计算能力导致性能发生改变, 则为一个瓶颈 进行优化: 指定发生瓶颈的阶段, 减小该阶段负载, 直到性能不再改善, 或者达到要求位置 重复 1, 2  如果无法对最慢的阶段优化, 可以增加其他部分的负载, 达到更好的效果(不等白不等)\n瓶颈定位策略 基本思想  使用 profile 查看耗时详细信息 基于工作量变化的控制变量法 排除法 管线每个阶段都依赖于 GPU 频率(GPU Core Clock, GPU Memory Lock), 可以使用 PowerStrip 减小相关时钟速度, 观察性能变化  应用程序阶段瓶颈定位  可以使用 profile 工具了解哪些 API 调用耗费高(CPU 占用状态), 但不能准确知道哪阶段减慢速度 采用基于工作量变化的控制变量法: 设置一系列测试, 每个测试减少特定阶段执行的工作量, 其中一个测试导致 FPS 增加, 则已经达到瓶颈阶段 或使用上述方法的排除法: 不降低工作量的前提减少其他阶段的工作量, 如果性能没改变, 则瓶颈为该阶段 对 CPU 进行降频(Underclock) 排除法: GPU 阶段无瓶颈则 CPU 为瓶颈所在  几何阶段瓶颈定位   顶点与索引传输阶段(Vertex and Index Transfer)的瓶颈定位\n  顶点变换阶段(Vertex Transformation Stage)的瓶颈定位\n  光栅化阶段瓶颈定位  光栅化操作瓶颈定位 片元着色器瓶颈定位 纹理带宽瓶颈定位  渲染管线的优化策略 对 CPU 的优化策略  减少资源锁定 批次的尺寸最大化  应用程序阶段优化策略  内存层面的最大化 代码层面的优化  API 调用策略  实例化(Instance)渲染 批处理(batching) 用不同颜色合并对象 共享材质(shared material) 理解对象缓冲(object bufffer)在渲染时的分配和存储方式  几何阶段的优化策略  减少顶点传输的开销 顶点处理的优化  光照计算的优化策略  尽量使用计算量少的光源类型 只对必要的多边形进行光照计算 控制光源的数量 使用烘焙照明(baking lighting) 使用环境贴图(environment map) 大量光源的情况下使用延迟渲染  光栅化的优化策略   一般策略\n 善用背面裁剪 在特定时期关闭 z-buffer 优先使用原生纹理和像素格式 进行合适的纹理压缩 基于物体和观察者之间的距离, 使用不同的像素着色器 通过计数得到通过 z 缓冲与否像素的数量, 得到进一步优化方法 early z pass    加速片元着色\n 优先渲染度 帮助 early-z 优化, 避免多余片元处理 在纹理中存储复杂功能, 如将纹理作为查找表(LUT) 将更多片元工作移到顶点着色器 使用必须的最低精度 避免过度标准化(normalization) 考虑使用 LOD 不必要的地方禁用三线性过滤 尽可能使用简单 shader 类型    减少纹理带宽\n 减少纹理尺寸 压缩所有彩色纹理 避免没必要的昂贵纹理格式 尽可能在小表面上使用 mip mapping    优化帧缓冲带宽\n 首先渲染深度 减少 alpha 混合 尽可能关闭深度写入 避免无关颜色缓冲区清除 默认大致上从前向后进行渲染 优化天空盒渲染, 按需选取策略 仅在必要时使用浮点帧缓冲区 尽可能使用 16 位 z-buffer 尽可能使用 16 位颜色    ","description":"性能优化","id":8,"section":"posts","tags":["cg"],"title":"游戏开发中渲染性能的优化","uri":"https://npchitman.com/posts/optimization/"},{"content":"纹理贴图是使用图像, 函数及其他数据来源来改变物体表面外观的技术\n纹理管线 The Texturing Pipeline 纹理管线是单个纹理应用纹理贴图的详细过程\n投影方程(projection function) 通过投影方程运用空间中的点, 得到参数空间值(parameter-space values)\n映射函数(correcponder function) 通过映射函数将参数空间值转到纹理空间(texture space location)\n获取纹理空间中相应的值(Obtain value) 使用纹理空间值获得相应的值, 可以使用图像纹理的数组索引来检索像素值\n值变换函数(value transform function) 使用值变换函数对检索结果进行替换\n最后使用得到的新值来改变表面属性(材质, 着色法线等)\n纹理类型 三维纹理/体纹理(3D/Volume Texture)  传统二维纹理(2D texture)在逻辑上的扩展 二维纹理是一张简单的位图图片, 用于为三维模型提供表面顶点值 一个三维纹理可以认为由很多二维纹理组成, 用于描述三维空间数据的图片, 通过三维座标访问 体纹理的优势:  直接用作纹理座标, 避免二维纹理发生的变形和接缝问题 使用三维纹理表示木材或大理石的体积结构, 看起来更逼真    立方体贴图 (Cube Map)   使用 6 幅二维纹理图像构成以原点为中心的纹理立方体:\n 每个 2D 纹理是一个立方体的一个面 每个片段纹理座标(s, t, r)被当作方向向量看待 每个纹素(texel)都表示从原点看到的纹理立方体上的图像    Cube Map 支持双线性滤波和 mip mapping, 可能会出现接缝处问题, 需要处理其他面的相邻样本, 每个纹素的角度范围等\n  程序贴图纹理 (Procedural Texturing)  通常用于离线渲染程序, 实时渲染更多使用图像纹理 通过计算机算法生成, 用于表现一些自然元素的真实表面(木材, 大理石, 花岗岩, 金属, 石头等) 通常使用分形噪声(fractal noise)和湍流扰动(turbulence functions)的随机性函数来生成纹理  凹凸贴图 (Bump Mapping) 通过纹理方法来产生凹凸不平的视觉效果, 主要原理是通过改变光照方程中的法线(不是表面的几何法线), 或对每个带渲染的像素计算照明前加上一个从高度图中的扰动, 模拟凹凸不平的视觉特征, 如褶皱, 波浪等\n 原理:  常见的凹凸贴图有:\n 凹凸贴图(Bump Mapping): 计算 vertex 光强时, 不直接使用该原始向量, 而是在原始法向量上加一个扰动得到修改法向量, 经过光强计算得到凹凸不平的表面效果 移位贴图(Displacement Mapping): 直接作用于 vertex, 根据移位贴图中对应 vertex 的像素值, 使 vertex 沿法向量移动, 产生真正的凹凸表面 法线贴图(Normal Mapping): 需要法向量信息, 可由高度贴图得到, 通过 rgb 通道存储法向量, 利用该信息计算光强, 产生凹凸阴影的效果(不增加多边形), 不发生自遮挡 视差贴图(Parallax/Virtaul Displacement Mapping): 以视线和 height map 计算比较陡峭的视角给 vertex 较多的位移, 较平缓的视角给 vertex 较少的位移 浮雕贴图(Relief Mapping): 能发生自遮挡, 闭塞的效果, 相当于\u0026quot;在 Shader 里做光线追踪\u0026quot;, 算法相对复杂  纹理缓存 (Texture Caching) 常见的纹理缓存使用策略:\n  最近最少使用策略(LRU, Least Recently Used)\n 加载到图形加速器中的每个内存都被给出一个时间戳, 用于最后一次访问已渲染图像时 当需要空间来加载新纹理时, 首先卸载最旧时间戳的纹理 可设置优先级: 如果两个纹理的时间戳相同, 优先卸载较低的纹理, 可以避免不必要的纹理交换    最近最常使用策略(MRU, Most Recently Used)\n 当前帧载入纹理时会发生抖动(Thrashing)的情况, 不适合使用 LRU(每帧画面中会对每张纹理图像进行交换) 使用 MRU 策略, 直到画面中没有纹理交换为止, 切换到 LRU    预取策略(Prefectching)\n 瓦片地图(tiles): 对于大数据纹理(如飞行和地形模拟系统), 传统方法将其分解成更小的硬件可以处理的 tiles 裁剪图(clipmap): 将整个数据集视为 mipmap; 对于任何特定视图, 只需 mipmap 较低级别的一小部分即可; 需要 GPU 支持 Dx10    纹理压缩 (Texture Compression)  固定速率纹理压缩(Fixed-rate Texture Compression): 通过硬件解码压缩处理, 可以使用更少的纹理内存, 从而增加有效的高速缓存大小  硬件上实现较昂贵 DxTC / BC(Block Compression, Dx10): Dx 的标准压缩模式, 使用 S3TC(S3 Texture Compression)方法, 通过创建一个固定大小, 具有独立的编码片段, 解码简单, 速度快, 每个压缩图片都可以单独处理, 无共享查找表(look up tables), 简化过程    ","description":"纹理贴图相关技术","id":9,"section":"posts","tags":["cg"],"title":"纹理贴图相关技术","uri":"https://npchitman.com/posts/texturing/"},{"content":"c++03 及之前的标准 c++03 及之前的标准中, 表达式的值类型(value categories)属性为左值或右值:\n 左值对应内存中确定存储地址的对象的表达式的值, 表达式结束后依然存在 非以上情况的表达式即为右值, 如字面量, 临时对象等表达式, 表达式结束后就不存在  左值与右值的根本区别在于是否允许取地址运算符\u0026amp;获得对应的内存地址, c++03 及之前的标准定义了表达式中左值到右值的三类隐式自动转换:\n 左值转右值: 如整数变量i在表达式 i + 3 数组名是常量左值, 表达式中转化为数组首个元素的地址值 函数名是左值, 表达式中转为函数的地址值  c++在用临时对象或函数返回值给左值对象时的深拷贝(deep copy)一直受诟病, 考虑到临时对象的生命周期仅在表达式中持续, 如果把临时对象的内容直接移动(move)给被赋值的左值对象, 效率改善将是显著的, 这就是移动语义的来源\nc++11 右值引用 右值引用是c++11引入的重要特性之一, 解决了大量历史遗留问题, 消除了诸如std::vector, std::string之类的额外开销, 并使std::function实现成为可能\n值类型 (value categories)  左值(lvalue): 表达式(不一定是赋值表达式)后依然存在的持久对象 右值(rvalue): 划分为纯右值和将亡值  纯右值(prvalue, pure value): 与c++03的右值概念相同, 要么是字面量(10, true), 要么是求值结果相当于字面量或匿名临时对象, 如1+2, 常见的纯右值有非引用返回的临时变量, 运算表达式产生的临时变量, 原始字面量, lambda表达式 将亡值(xvalue, expiring value): 即将被销毁, 确能够被移动的值    1 2 3 4 5 6  std::vector\u0026lt;int\u0026gt; foo(){ std::vector\u0026lt;int\u0026gt; temp = {1, 2, 3, 4}; return temp; } std::vector\u0026lt;int\u0026gt; v = foo();   以上代码在c++03之前, 函数foo的返回值temp在内部创建, 赋值给v, v在获得该对象时, 会将temp拷贝一份, 然后把temp销毁, 如果temp非常大那将造成大量额外的开销(传统c++饱受诟病的问题)\n最后一行中, v是左值, foo()返回纯右值, foo()产生的返回值一旦被v复制后, 将立即销毁, 无法获取也不能修改\n将亡值定义了一种行为: 临时值能够被识别, 同时又能被移动\nc++11后, 编译器会做以下工作: 左值temp会被隐式右值转换, 等价于static_cast\u0026lt;std::vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;\u0026amp;\u0026gt;(temp), 此处的v会将foo局部返回值进行移动, 即移动语义(Move Senmatics);\n右值引用的形式 1 2 3  A a; A\u0026amp; a_ref1 = a; // 在类型后加上\u0026amp;表示左值引用 A\u0026amp;\u0026amp; a_ref2 = a; // 在类型后加上\u0026amp;\u0026amp;表示右值引用   右值引用可以绑定临时变量, 左值引用不行\n1 2  A\u0026amp; a_ref3 = A(); // 不合法 A\u0026amp;\u0026amp; a_ref4 = A(); // 合法   和左值引用的组合可以实现移动语义, 右值引用还能实现完美转发, 实现更高效, 更通用的代码\n引用折叠(Reference Collapsing) 由于 c++中禁止reference to reference, 编译器需要对四种情况(LL, LR, RL, RR)进行处理, 将其整理成单一的引用\n引用折叠规则:\n 所有右值引用折叠到右值引用上仍是一个右值引用(A\u0026amp;\u0026amp; \u0026amp;\u0026amp; -\u0026gt; A\u0026amp;\u0026amp;) 所有其他引用类型之间的折叠都将变成左值引用  万能引用 (Universal Reference)  \u0026amp;\u0026amp;既能接收左值类型的参数, 也能接收右值类型的参数, 形式如下:  1 2 3 4  template\u0026lt;typename T\u0026gt; ReturnType Function(T\u0026amp;\u0026amp; param){ // TODO: }   移动语义 (Move Semantics) 移动的意思是转移所有权, 由于右值都是临时的值, 临时值释放后不再持有属性的所有权, 相当于转移资源所有权的行为, 除了临时值, 左值在一些情况下也适合转移所有权:\n1 2 3 4 5 6  void func(){ std::vector result; // 此时将result赋值给ans后不再被使用  if(xxx){ans = result;} return; }   移动语义通过右值引用支持, 用于减少值复制带来的开销, 提升性能\n复制在一些情况(如向量复制, 通常是函数调用的情况)的资源消耗高, 某些情况下本意并不需要两个副本, 而是想要将值\u0026quot;移动\u0026quot;到另一个变量上:\n下面的交换函数, 作出了三次拷贝操作仅仅是为了修改原先的值:\n1 2 3 4 5  template\u0026lt;class T\u0026gt; swap(T\u0026amp; a, T\u0026amp; b){ T tmp(a); // a 发生拷贝  a = b; // b 发生拷贝  b = tmp; // tmp 发生拷贝 }   使用 move 消除不必要的拷贝:\n1 2 3 4 5  template\u0026lt;class T\u0026gt; swap(T\u0026amp; a, T\u0026amp; b){ T tmp(std::move(a)); a = std::move(b); b = std::move(tmp); }   move 函数返回参数的值, 但是不强制保留源参数的值, 例如使用 move 将 vectorB 的元素移动到 vectorA, 执行完该语句后, vectorA 获得了 vectorB 的元素, 此时 B 内为空, 里面的内容已经\u0026quot;移动\u0026quot;到 A 中:\n1  A = std::move(B);   move 的定义如下, 参数接收左值或右值参数, 将其作为右值返回, 不会触发复制构造函数:\n1 2 3 4 5  template \u0026lt;class T\u0026gt; typename remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; move(T\u0026amp;\u0026amp; a){ return a; }   由于 move 使参数变为临时变量, 不能被程序其他地方引用, 所以保证了移动语义的运作\n在类中实现移动构造函数(move constructor)来用作移动语义(或者可以实现移动赋值运算符), 编译器通常不会提供移动构造函数的默认实现\n完美转发 (Perfect Forwarding) 一个声明的右值引用其实是一个左值, 进行参数转发的时候造成了一些问题:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void reference(int\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;左值\u0026#34; \u0026lt;\u0026lt; std::endl; } void reference(int\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;右值\u0026#34; \u0026lt;\u0026lt; std::endl; } template \u0026lt;typename T\u0026gt; void pass(T\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;普通传参:\u0026#34;; reference(v); // 始终调用 reference(int\u0026amp;) } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;传递右值:\u0026#34; \u0026lt;\u0026lt; std::endl; pass(1); // 1是右值, 但输出是左值  std::cout \u0026lt;\u0026lt; \u0026#34;传递左值:\u0026#34; \u0026lt;\u0026lt; std::endl; int l = 1; pass(l); // l 是左值, 输出左值  return 0; }   pass(1)来说, 虽然传递的是右值, 但由于v是一个引用, 所以同时也是左值, 因此reference(v)会调用reference(int\u0026amp;), 输出左值, 而对于pass(l)而言, l是一个左值, 由于引用折叠的原因, \u0026amp;\u0026amp;可以作为\u0026quot;万能引用\u0026quot;, 成功传递;\nstd::forward用作完美转发, 用于保持原来的值属性(左右)不变, 定义如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13  // 左值应用模板函数 template \u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp; param) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); } // 右值应用模板函数 template \u0026lt;typename T\u0026gt; T\u0026amp;\u0026amp; forward(typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; param) { return static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(param); }   forward实现了两个模板函数, 一个接收左值, 一个接收右值, forward对参数进行强制转换, 转换的目标类型符合引用折叠规则, 左值参数最终转换后仍为左值, 右值参数最终转为右值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  #include \u0026lt;iostream\u0026gt;#include \u0026lt;utility\u0026gt;void reference(int\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;左值引用\u0026#34; \u0026lt;\u0026lt; std::endl; } void reference(int\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34;右值引用\u0026#34; \u0026lt;\u0026lt; std::endl; } template \u0026lt;typename T\u0026gt; void pass(T\u0026amp;\u0026amp; v) { std::cout \u0026lt;\u0026lt; \u0026#34; 普通传参: \u0026#34;; reference(v); std::cout \u0026lt;\u0026lt; \u0026#34; std::move 传参: \u0026#34;; reference(std::move(v)); std::cout \u0026lt;\u0026lt; \u0026#34; std::forward 传参: \u0026#34;; reference(std::forward\u0026lt;T\u0026gt;(v)); std::cout \u0026lt;\u0026lt; \u0026#34;static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt; 传参: \u0026#34;; reference(static_cast\u0026lt;T\u0026amp;\u0026amp;\u0026gt;(v)); } int main() { std::cout \u0026lt;\u0026lt; \u0026#34;传递右值:\u0026#34; \u0026lt;\u0026lt; std::endl; pass(1); std::cout \u0026lt;\u0026lt; \u0026#34;传递左值:\u0026#34; \u0026lt;\u0026lt; std::endl; int v = 1; pass(v); return 0; }   无论传递参数是左值还是右值, 普通传参都会将参数作为左值进行转发, 所以std::move总是接受到一个左值, 从而转发调用了reference(int\u0026amp;\u0026amp;)输出右值引用\n总结 右值引用区分了左值和右值, 使用右值引用来减少不必要的内存分配提升程序性能, 还能减少引用类型不同带来的函数重载\n","description":"对c++11中右值引用, 移动语义, 完美转发的理解","id":10,"section":"posts","tags":["c++"],"title":"c++右值引用","uri":"https://npchitman.com/posts/rvalue_reference/"},{"content":"锯齿, 抗锯齿 锯齿   奈奎斯特极限(Nyquist Theorem): 采样频率是原始信号中最高频率的两倍\n  根本原因是因为采样分辨率不足, 要采样的最高频率超过奈奎斯特极限(Nyquist Limit), 产生锯齿(jaggies)\n 采样频率: 显示器给定的分辨率 采样对象频率: 显示的图像的最高频率    锯齿按表现分类:\n 几何锯齿(Geometric Aliasing): 光栅化采样不足导致, 体现几何边缘的锯齿现象 着色锯齿(Shading Aliasing): 渲染(如光照计算)的采样不足导致, 体现在画面中的部分像素点的闪烁或噪点    最好的解决方法是提高采样频率, 即显示分辨率, 但多数情况不能满足, 故需要使用其它技术\n  抗锯齿   抗锯齿(AA, anti-aliasing), 也称为反走样, 边缘柔化, 消除混叠, 抗图像折叠有损, 用于消除显示器输出画面中物体边缘出现锯齿的技术\n  抗锯齿分类:\n  空域抗锯齿技术(柔化边缘): 通过超采样几何边缘达到模糊边缘的效果, 理论上通过低通滤波抑制几何边缘高频信息, 只能缓解几何锯齿, 对着色锯齿无效\n  帧间抗锯齿技术(分摊采样压力): 通过加权混合相邻多帧达到抗锯齿效果, 理论上解释就是将计算量分摊(Amortized)至多帧的超采样(Super-Sampling), 能够有效缓解几何锯齿和着色锯齿, 通常需要修正历史帧像素, 否则会出现拖影\n  基于图像后处理\n  增加采样数\n  基于深度学习\n    帧间相关性(frame-to-frame coherence): 相邻的两帧画面通常是平滑过渡的, 较少出现突变\n  量化抗锯齿技术的好坏可以从效果和消耗出发\n  超级采样抗锯齿 SSAA (Super Sampling)  比较早期的抗锯齿算法, 比较消耗资源 原理是先将图像映射到缓存并放大, 再用超级采样把放大的图像像素进行采样, 通常选取 2/4 个临近像素, 混合后生成最终像素 通常使用两种超级采样法:  顺序栅格超级采样 (OGSS, Ordererd Grid Super-Sampling), 采样时选取 2 个临近像素 旋转栅格超级采样 (RGSS, Rotated Grid Super-Sampling), 采样时选取 4 个临近像素   全场景抗锯齿(FSAA, Full-Scene Anti-Aliasing): 以较高的分辨率对场景进行绘制, 然后对相邻的采样样本进行平均  多重采样抗锯齿 MSAA(Multi Sampling)  特殊的超级采样抗锯齿(SSAA), 来自于 OpenGL MSAA 只对z-buffer和stencil-buffer中的数据进行 SSAA 的处理, 即只对多边形边缘进行处理 相比 SSAA 资源消耗大大减弱(通常还有 GPU 支持加速), 但画质表现会损失一些 MSAA 对于半透明物体, 边缘不明确或者非常复杂的物体(草丛, 铁丝网)的处理比较力不从心 不适合延迟渲染(光栅化信息存在 GBuffer), 适用在前向渲染中  子像素增强抗锯齿(SMAA Enhanced Subpixel Morphological)  后处理抗锯齿 与 FXAA 类似, 性能消耗小, 比 FXAA 清晰 处理流程建立在 MLAA 算法上 动态画面上效果不好, 可以和 TAA 同时开启  覆盖采样抗锯齿 CSAA(Coverage Sampling)  在 MSAA 基础上进一步节省显存使用量及带宽 CSAA 将边缘多边形里需要取样的子像素覆盖掉, 把原像素坐标强制安置在硬件和驱动程序预先算好的坐标中, 相比于 MSAA 能够最高效率地执行边缘取样, 16xCSAA 性能下降相当于 4xMSAA, 效果相当于 8xMSAA  高分辨率抗锯齿 HRAA/Quincunx (High Resolution)  出自 Nvidia, 五点梅花状采样, 其中四个样本在像素单元的角上, 最后一个在中心  可编程过滤抗锯齿 CFAA (Custom Filtter)  扩大取样面积的 MSAA, 可以更灵活选取对抗锯齿影响较大的像素进行缩放, 以较少的性能牺牲换取平滑效果, 从而减小显卡资源消耗  形态抗锯齿 MLAA (Morphological)  出自 AMD, 完全基于 CPU 处理的后处理抗锯齿方案 MLAA 将跨越边缘像素的前景和背景色进行混合, 用第二种颜色填充该像素, 更有效改进图像边缘的变现效果 资源消耗较大 仅使用颜色辨识, 无法辨识哪些边缘需要进行计算, 导致文字, 表格受到影响  快速近似抗锯齿 FXAA (Fast Approximate)  传统 MSAA 的一种高性能近似, 可以同时开启, 是后处理抗锯齿 FXAA 是一种单程像素着色器, 相比 MLAA 不依赖于 GPU 的 API, 兼容不同硬件 性能比 MLAA 好, 画面接近于 MSAA 会出现字体破坏情况, 但不会造成镜面模糊和亚像素模糊(闪烁现象/时间性锯齿)  TAA (Temporal)   样本点分摊在时域上的超采样\n  能在延迟渲染上使用\n  以后处理的方式融入渲染流\n  相机抖动: 相机随时间抖动时, 引入了额外的子像素信息, 通过融合子像素获得时域上的超采样效果, 使得静态场景中与 SSAA 效果一致\n  实现细节\n 开始移动相机: 利用图形学的 Motion Vector 计算像素点当前帧和上一帧的移动 采样出现的问题: 移动相机后, 历史像素上, 因为当前画面的一个矩形像素点不可能刚好映射到上一帧的矩形像素, 需要引入插值来近似上一帧颜色, 导致像素模糊 遮挡/动态物体: 即历史像素与当前像素毫无关联的情况, 时域 EMA 加权给历史像素很大的权重, 导致历史画面残留在当前画面上, 需要丢弃无关样本, 解决方案是使用颜色空间的 Clipping, 计算当前像素机器邻域的均值和方差, 若历史颜色不在这个范围内, 则丢弃, 丢弃后的颜色与当前颜色重新进行加权 物体边缘: 单纯使用 Motion Vector, 仍会出现锯齿, 解决方式是取 Motion Vector3x3 邻域最长的向量 闪烁: 不收敛, 闪烁, 子像素出现在最高票信息中, 混合过程中, 少量高频信号极大影响混合后效果, 导致像素闪烁    时间性抗锯齿 TXAA (Temporal)  TAA + MSAA, 通过引入额外的深度信息来实现延迟渲染中使用 MSAA TXAA 还能对帧之间的整个场景进行抖动采样, 减少闪烁(时间性锯齿) TXAA 目前有 2X 和 4X 两种模式, 2X 效果堪比 8X MSAA, 性能减少相当于 2X MSAA  多帧采样抗锯齿 MFAA (Multi-Frame)  MSAA 的优化版, 近乎相同效果同时提升性能 只有 Maxwell 架构的 GPU 显卡才能使用 同样开启 4 倍效果时  MSAA 针对每个边缘像素周围 4 个像素进行采样 MFAA 采用交错的方式采样边缘某个像素周围的两个像素    ","description":"常见抗锯齿技术分类与原理","id":11,"section":"posts","tags":["cg"],"title":"抗锯齿类型总结","uri":"https://npchitman.com/posts/anti-aliasing/"},{"content":"正向渲染 (Forward Rendering/Shading)   根据所有光源照亮一个物体, 之后再渲染下一个物体\n  传统正向渲染思路: 先着色, 再进行深度测试\n  复杂度与光源关系很大, n 个受到光源影响的物体, m 个光源, 复杂度为 O(m*n), 比较适合户外光源较少的情形\n  程序要对每个光源需要渲染的片段进行迭代, 如果旧的片段被新的覆盖(深度测试), 最终不显示, 就造成了浪费\n  实现简单, 影响性能较大\n  使用延迟渲染(Deferred Rendering)来解决大量光源的场景\n  延迟渲染 (Deferred Rendering)  基本思想: 在二维空间进行光照计算(先深度测试, 再着色) 几何缓冲区(G-buffer, Geometric Buffer): 延迟渲染将所有物体先绘制到这里, 再逐光源进行着色, 避免深度测试后丢弃的片元被计算 对于 O(m*n)的正向渲染(n 个物体, m 个光源), 标准的延迟渲染为 O(m+n): m 次物体绘制 + n 次光源着色  几何缓冲区 (G-Buffer)   G-Buffer 用于存储像素对应的位置(Position), 法线(Normal), 漫反射颜色(Diffuse Color)等, 根据这些信息, 在二维空间中进行光照处理\n  G-Buffer 直接存储位置, 颜色, 法线等对象到帧缓存中, 过程几乎不消耗处理时间, 非常高效\n  深度测试已经将不需要的信息消除, 只用渲染需要的信息, 省下很多无用的调用\n  优化空间大, 能够渲染更多的光源\n  处理过程:\n 几何处理阶段(Geometry Pass): 获取对象的各种几何信息, 将第二步所需的各种数据存储(渲染)到多个 G-buffer 中 光照处理阶段 A(Lighting Pass): 渲染屏幕大小的二维矩形, 使用第一步在 G-buffer 中存储的数据对此矩阵进行着色计算(计算过程与正向渲染一样, 输入变量的位置变为 G-buffer)    优点:\n 复杂度 O(m + n) 只渲染可见像素 使用更少的 shader 后处理支持好 大光源下优势明显    缺点:\n 内存开销较大 读写 G-buffer 的内存带宽用量是性能瓶颈 对透明物体渲染需要结合正向渲染 对 MSAA 支持不友好, 需要开启 MRT    改进方法 主要有两种方法:\n 延迟光照(Light Pre-Pass, Deferred Lighting): 最小化 G-Buffer 数据结构 分块延迟渲染(Tile-Based Deferred Rendering): 将多个光照组合处理  延迟光照(LightPre-Pass/Deferred Lighting)  减少 G-buffer 开销(reduce G-buffer overhead) 对 MSAA 使用有利(使用 z 值和 normal, 很容易找到边缘) 具体思路:  几何阶段(Geometry Stage): 渲染场景中不透明(opaque)的几何体, 将法向量 n 和镜面扩展因子(specular spread factor)m 写入缓冲区, 即 n/m-buffer, 类似于 G-buffer, 包含信息更小更轻量, 适合输出单个缓冲区, 不需要 MRT 支持 光照阶段(Lighting Stage): 计算漫反射和镜面着色方程, 将结果写入不同的漫反射和镜面反射累积缓冲区(Light Accumulation Buffer), 可以在单独的 pass 中完成(使用 MRT)或者两个, 环境光照可以使用 full-scene pass 进行计算 着色阶段(Shading Stage): 对场景中不透明几何体进行第二次渲染, 从纹理中读取漫反射和镜面反射值, 对前面步骤中漫反射和镜面反射累积缓冲区进行调整, 将最终结果写入颜色缓冲区, 若上阶段没有处理环境光, 则该阶段处理, 只需计算累积缓冲区的信息    分块延迟渲染(TBDR, Tile-Based Deferred Rendering)   传统 DR 的问题: 每个光源即使重叠, 仍是独立进行, 会重复读取 G-buffer 中相同位置的数据, 计算后以相加混合方式写入颜色缓冲, 光源数量会影响内存带宽用量\n  TBDR 思想: 将屏幕划分成细小的栅格(如 32x32 像素为一个 Tile), 计算每个分块受到哪些光源影响, 将光源索引存储在分块光源列表里, 最后逐个方块进行着色, 对每像素读取 G-Buffer 和光源列表及相关信息, 大致步骤如下:\n 将屏幕分成一个个小块 tile 根据这些 Depth 求得每个 tile 的 bounding box 对每个 bounding box 和 light 进行求交, 得到与该 tile 作用的 light 序列 根据得到的序列计算 tile 的光照效果    G-buffer 数据只会被读取一次, 写入 color buffer 也是 1 次, 大幅降低内存带宽用量\n  compute shader: 在渲染管线外进行, 通常处理大量并行计算, 节省 CPU 资源\n  该方法需要进行光源剔除(light culling, 计算光源影响哪些分块), 可以在 CPU 或 GPU(通常使用 compute shader)中实现, 使用 GPU 更快, 减少 CPU-GPU 传输, 并且可以计算每个分块的深度范围(depth range), 更有效地剔除\n  合理分摊开销, 性能优于 Light Pre-Pass\n  ","description":"延迟渲染","id":12,"section":"posts","tags":["cg"],"title":"延迟渲染技术","uri":"https://npchitman.com/posts/deferred-rendering/"},{"content":"核心 微平面理论(Microfacet Theory)  将物体表面建模成无数微观尺度上有随机朝向的理想镜面反射的小平面(microfacet) 实际 PBR 工作流中, 微平面通过粗糙度贴图或高光贴图来表示 微观尺度上, 表面越粗糙反射越模糊, 越光滑反射越集中 到达微观尺度后任何平面都可以用称为微平面的细小镜面来进行描绘 用统计学的方法估算微平面粗糙程度  半程向量(Halfway Vector): 位于光线向量 l 和视线向量 v 之间的中间向量 用基于一个平面的粗糙度(Roughness)来计算出半程向量的方向与微平面平均取向方向一致的概率    能量守恒(Energy Conservation)   入射光线能量 \u0026gt;= 出射光线能量\n  随着粗糙度上升, 镜面反射区域面积增加, 平均亮度下降\n  出射光线能量不能超过入射光线能量 (发光面除外)\n  镜面反射光照 (反射部分): 光线不进入平面直接反射的光线\n  漫反射光照 (折射部分): 光线进入表面被吸收的光线\n 光线与粒子碰撞后吸收光线所携带的一部分或是全部能量, 转为热量 并非所有能量会被全部吸收, 光线会继续沿着随机方向发散, 再和其他粒子碰撞直至能量完全耗尽或者再次离开这个表面 光线脱离物体表面后将会协同构成该表面的(漫反射)颜色 PBR 对漫反射进行简化, 假设平面上每一点所有折射光都会被完全吸收而不会散开 保留次表面散射(Subsurface Scattering)的着色器能更好地显示皮肤, 大理石, 蜡质等类视觉效果    金属 (Metallic) 表面的反射与非金属(介电质Dielectrics)不同:\n 金属反射原理与折射原理相同 金属不会显示漫反射颜色 (所有折射光会被直接吸收而不会散开, 只留下反射光)    反射光与折射光互斥, 光线被反射无法被吸收, 折射光余下的进入表面中的能量正好是计算完反射后余下的能量\n  菲涅尔反射(Freshnel Reflection)  表示观察看到的反射光线的向量与视角相关的现象 光线以不同角度入射会有不同反射率, 掠射角度(90)下反射率最大 F0: 平行于表面法向量入射的菲涅尔反射值, 任意角度的菲涅尔反射可由 F0 和入射角度计算得出 光线对于不同物质有不同的反射率, 非金属 F0: 0.02~0.04, 金属 F0: 0.7~1.0  线性空间光照(Linear Space Lighting)  线性(向量)空间: 数字化的颜色和光照强度进行相加相乘计算的结果依然能与真实的结果一致 伽马矫正(gamma correction):  对图像进行非线性处理 具体实现是对图中每个像素做一次幂函数运算 图片文件夹存储的都是伽马纠正过的颜色值   PBR 将贴图和颜色去除伽马纠正从伽马空间转换到线性空间, 再传递给着色器进行光照计算 线性空间下渲染管线流程: 去除伽马纠正-\u0026gt;着色-\u0026gt;伽马纠正-\u0026gt;显示 颜色值的计算和操作必须在线性空间中执行 描述物体表面属性的贴图(如粗糙度, 高光贴图, 金属贴图)必须保证是线性空间  色调映射/复制(Tone Mapping/reproduction)  表示以感知上令人信服的方式将 HDR 场景的强度值转换为显示强度的过程(将宽范围光照级别拟合到屏幕的有限色域的过程) 基于HDR渲染出来的亮度值会超过显示器能显示的亮度, 需要使用色调映射转为LDR(显示器能正常显示)  物质的光学特性(Real-World Measurement Based Substance Properties)  物质分为三大类: 绝缘体(Insulatiors), 半导体(semi-conductors), 导体(conductors) 渲染和游戏通常只关注导体和绝缘体 菲涅尔反射率代表材质的反射颜色和强度, 是真实世界的核心测量数值 非金属反射颜色: 单色/灰色镜面反射颜色(单个 float) 金属反射颜色: 彩色镜面反射(RGB)  光照与材质解耦(Decoupling of Lighting and Material)  保证场景中所有对象有视觉一致性, 相同光照可以应用于所有物体和材质, 无需传统光照模型的额外调整, 提升美术工作效率  光学 (Optics) 几何光学/射线光学 (Geometrical Optics) 光与介质边界交互原理 一束光射到物体表面时, 由于物体表面与空气两种介质之间折射率的快速变化, 光线会发生反射和折射:\n  反射(Reflection):\n 光线在两种介质交界处的直接反射, 即镜面反射 镜面反射占入射光线的比率由菲涅尔方程计算    折射(Refraction): 从表面折射入介质的光, 会发生吸收(absorption)和散射(scattering), 介质的整体外观由散射和吸收特性决定\n  散射(Scattering): 由观察尺度划分\n 漫反射(Diffuse): 观察像素大于散射距离 次表面散射(Subsurface Scattering): 观察像素小于散射距离 透射(Transmission): 入射光经过折射穿过物体后的出射现象, 为次表面散射的特例    吸收(Absorption): 具有复折射率(complex number)的物质区域会引起吸收\n  光与不同物质交互 根据材质光学特性分为金属和非金属:\n   类型 反射 折射(散射) 折射(吸收)     金属 为三通道颜色 几乎无散射 立刻被自由电子吸收   非金属(均匀介质) 单通道颜色 无散射 无折射率变化   非金属(非均匀 - 浑浊介质) 单通道颜色 弱散射, 方向略微随机化 \u0026mdash;   非金属(非均匀 - 半透明介质) 单通道颜色 强散射, 方向完全随机化 \u0026mdash;   非金属(非均匀 - 不透明介质) 单通道颜色 强散射, 方向完全随机化 \u0026mdash;      金属(Metal)\n 外观主要取决于镜面反射, 折射的光线几乎全被自由电子吸收, 且不存在散射 反射颜色为三通道颜色    非金属(No-Metal): 即电介质(Dielectric), 整体外观主要由吸收和散射的特性组合决定\n 反射(Reflection): 单通道颜色(R=G=B) 折射(Refraction): 整体外观由散射和吸收的特性组合决定, 不同介质类型散射和吸收特性:  均匀介质(Homogeneous Media): 主要为透明介质, 无折射率变化, 不存在散射, 光直线传播不改变方向, 强度会通过吸收减少 非均匀介质(Nohomogeneous Media): 通常可以建模为具有嵌入散射粒子的均匀介质, 具有折射率变化  浑浊介质(Cloudy Media): 具有弱散射, 散射方向略微随机化, 根据组成不同具有复数折射率的区域引起吸收 半透明介质(Translucent Media): 具有强散射, 散射方向完全随机化, 根据组成不同具有复数折射率的区域引起吸收 不透明介质(Opaque Media): 与半透明介质一致        半导体(semiconductor) : 综合金属和非金属的特性\n  真实世界的材质渲染 辐射度量学 (Radiometry)  辐射度量学是用来度量电磁场辐射(包括可见光)的手段, 多种辐射度量(radiometric quantities)用来测量曲面或某个方向的光, 其中辐射率(Radiance)与反射率方程有关  常见辐射量单位    物理量 说明     辐射能(Radiant energy) 能量   辐射通量/功率(Radiant flux) 单位时间的辐射能量   辐射度(Radiosity) 表面出射和反射的辐射通量总和   辐射出射度(Radiant exitance) 表面出射的辐射通量   辐射强度(Radiant intensity) 单位立体角的辐射通量   辐射率(Radiance) 单位立体角的单位投射表面的辐射通量   辐照度(Irradiance) 入射表面的辐射通量    辐射率(Radiance)   辐射率用来量化单一方向发射来的光线大小或强度, 辐射度量学上表示一个区域平面上光线总量的物理量, 受到入射(Incident)光线与平面法线间夹角的余弦值影响\n  组成辐射率的物理变量:\n  辐射通量/功率(Radiant flux):\n 表示一个光源所输出的能量; 可以看作该光源包含各种波长的一个函数, 辐射通量计算该函数的总面积; 以瓦特为单位, 通常使用 RGB 来作为辐射通量的表示, 对于视觉上的影响可以忽略;    立体角(Solid Angle):\n 投射到单位球体上的一个截面的大小或者面积 将立体角和面积看作无穷小(面转为点, 立体角转为方向向量), 就可以用辐射率表示单束光线穿过空间中的一点    辐射强度(Radiant Intensity):\n 表示单位球面上, 一个光源向每单位立体角所投送的辐射通量 用于计算单位面积(立体角)能量大小      渲染方程 反射率方程   渲染方程(Render Equation):\n 描述了光能在场景中的流动, 目前用来模拟光视觉最好的模型 物理基础是能量守恒定律    反射率方程(The Reflectance Equation):\n 基于 PBR 的渲染方程的特化版本(近似)    双向反射分布函数 BRDF BRDF 介绍 (BRDF, Bidrectional Reflective Distribution Function)\n BRDF 用于描述光如何从给定的两个方向(入射光方向 l 和出射光方向 v)表面进行反射的函数 定义：出射辐射率的微分(differential outgoing radiance)和入射辐照度的微分(differential incoming irradiance), 即辐射率(radiance)和辐照度(irradiance)之比 输入: 光的入射, 出射方向, 平面法线, 微平面粗糙度 输出: (近似) 每束光线 对一个材质平面 最终反射的光线的权  (能量守恒) 完全光滑情况, 所有入射光线 BRDF 返回 0.0, 只有一束与出射光线拥有相同的角度光线会得到 1.0 返回值   BRDF 具有可逆性, 遵循能量守恒(经验模型不一定满足), 线性特征(可进行多重 BRDF 计算镜面漫反射) BRDF 模型可以分为三类: 经验模型(Empirical Models), 数据驱动模型(Data-driven Models), 基于物理的模型(Physical-based Models) 采用入射和出射方向作为参数的Blinn-Phong也认为是一个 BRDF, 由于不遵循能量守恒, 不是 PBR 实时渲染管线通常使用 Cook-Torrance BRDF BxDF:  对于 BRDF(反射), BTDF(折射), BSDF(散射), BSSRDF(次表面散射)等几种双向分布函数的一个统一表示 BSDF = BRDF + BTDF BSSRDF: 相比与 BRDF 可以指定不同光线入射位置和出射位置 BSDF, BTDF, BSSRDF 用于表示透明材质和次表面散射材质    漫反射 BRDF(Diffuse BRDF)   传统型:\n Lambert    基于物理模型:\n Oren Nayar Simplified Oren-Nayar Disney Diffuse Renormalized Disney Diffuse Gotanda Diffuse PBR diffuse for GGX+Simth MultiScattering Diffuse    Disney Principled BRDF   着色模型是艺术导向(Art Directable), 不一定要完全物理正确(physically correct)\n  核心理念:\n 应使用直观的参数, 非物理类晦涩参数 参数尽可能少 参数合理范围在 0-1 允许参数在有意义时超出正常的合理范围 所有参数组合应尽可能健壮和合理    BRDF 参数:\n baseColor(基础色): 表面颜色, 通常由纹理提供 subsurface(次表面): 使用次表面近似控制漫反射形状 metallic(金属度): 金属(0=电介质, 1=金属), 两种不同模型间的线性混合, 金属模型无漫反射 specular(镜面反射强度): 入射镜面反射量, 用于取代折射率 specularTint(镜面反射颜色): 对美术控制的让步, 用于基础色(base color)的入射镜面反射进行颜色控制, 掠射镜面反射仍然非彩色 roughness(粗糙度): 表面粗糙度, 控制漫反射和镜面反射 anisotropic(各向异性强度): 各向异性强度, 用于控制镜面反射高光的纵横比(0 同向异性, 1 各向异性) sheen(光泽度): 额外的掠射分量(gazing component), 主要用于布料 sheenTint(光泽颜色): 对 sheen 的颜色控制 clearcoat(清漆强度): 有特殊用途的第二个镜面波瓣(specular lobe) clearcoarGloss(清漆光泽度): 控制透明图层光泽度, 0 = \u0026ldquo;缎面(satin)\u0026ldquo;外观, 1 = \u0026ldquo;光泽(gloss)\u0026ldquo;外观    镜面反射 BRDF(Specular BRDF)  目前业界主流基于物理的 Specular BRDF: Microfacet Cook-Torrance BRDF  Cook-Torrance BRDF 模型   由漫反射(Lambertian)和镜面反射(cook-torrance)组成\n  Lambertian: c / π\n π 用于对漫反射光进行标准化 足够应付大多数实时渲染    cook-torrance: DFG / 4(ωo⋅n)(ωi⋅n)\n Specular D: 法线/镜面分布函数, 估算受到表面粗糙程度情况下, 取方向与半程向量一致的微平面数量, 用来估算微平面的主要函数 Specular F: 菲涅耳方程, 不同的表面角下表面所反射的光线所占的比率 Specular G: 几何函数, 描述了微平面自成阴影的属性, 当一个平面比较粗糙, 微平面可能挡住其他微平面减少反射的光线    UE4 使用的函数:\n Specular D: Trowbridge-Reitz GGX Specular F: Fresnel-Shilick Approximation Specular G: Smith\u0026rsquo;s Schlick-GGX    法线分布函数( Normal Distribution Function )  统计学上近似表示半程向量 h 取向一致的微平面比率 输入: 材料的粗糙程度 Trowbridge-Reitz GGX in GLSL:  1 2 3 4 5 6 7 8 9 10 11 12  float D_GGX_TR(vec3 N, vec3 H, float a){ float a2 = a * a; float NdotH = max(dot(N, H), 0.0); float NdotH2 = NdotH * NdotH; float nom = a2; float denom = (NdotH2 * (a2 - 1.0) + 1.0); denom = PI * denom * denom; return nom / denom; }   几何函数 (Geometry Function)  从统计学上近似求得微平面间互相遮蔽的比率, 相互遮蔽会损耗光线的能量 输入: 材料的粗糙程度, 粗糙度较高的表面, 其平面间的相互遮蔽概率就越高 使用的几何函数: Schlick-GGX: (GGX, Schlick-Beckmann) 为了有效估算几何部分, 需要考虑:  观察方向(Geometry Obstruction) 光线方向向量(几何阴影(Geometry Shadowing))   使用史密斯法(Smith's method)包含观察方向和光线方向向量 Schlick-GGX in GLSL:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  float GeometrySchlickGGX(float NdotV, float k){ float nom = NdotV; float denom = NdotV * (1.0 - k) + k; return nom / denom; } float GeometrySmith(vec3 N, vec3 V, vec3 L, float k){ float NdotV = max(dot(N, V), 0.0); float NdotL = max(dot(N, L), 0.0); float ggx1 = GeometrySchlickGGX(NdotV, k); float ggx2 = GeometrySchlickGGX(NdotL, k); return ggx1 * ggx2; }   菲涅尔方程 (Fresnel Requation)   描述被反射的光线对比光线被折射部分所占的比率, 这个比率会随着观察角度不同而不同\n  当光线碰撞到一个表面时, 菲捏尔方程会根据观察角度求得被反射光线的占比, 根据能量守恒原则, 可以直接得出光线被折射的部分以及剩余能量\n  折射指数(IOR, Indices of Refraction): 光在传播到两种不同介质交界处(穿过)时, 原始光波和新的光波的相速度(Phase Velocity)的比率\n  垂直观察物体时该表面只有基础反射率(Base Reflectivity), 利用折射指数计算得出\n  当视线法线夹角增大时反射性会增大, 90 度理论上能完全反射光线\n  使用Freshnel-Schlick近似法求得近似解 ( 菲涅尔原始方程较复杂 )\n  仅对非金属表面(介电质)有效, 对于导体(Conductor)表面, 使用IOR计算F0不能得出正确的结论, 需要分别使用不同的菲涅尔方程, 很麻烦\n  统一金属和非金属公式: 通常预先计算出F0, 然后基于相应观察角的Freshnel-Schlick近似对这个值进行插值\n  F0规律: 非金属通常不会高于 0.17, 导体材质大多在 0.7-1.0\n  Freshel Schlick in GLSL:\n  1 2 3 4 5 6 7  // calc F0 // vec3 F0 = vec3(0.04); // F0 = mix(F0, surfaceColor.rgb, metalness);  vec3 freshnel Schlick(float cosTheta, vec3 F0){ return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0); }   ","description":"PBR理论基础","id":13,"section":"posts","tags":["CG"],"title":"PBR理论基础","uri":"https://npchitman.com/posts/pbr-theory/"},{"content":"渲染管线主要功能是对给定虚拟相机, 三维物体, 光源, 照明模式, 纹理等条件情况下, 生成一副二维图像的过程\n图形渲染管线工作流程 主要包含四个阶段: 应用阶段(Application Stage), 几何阶段(Geometry Stage), 光栅化阶段(Rasterization Stage), 像素处理阶段(Pixel Processing Stage)\n应用阶段(Application) 图像在应用中的处理阶段, 运行在 CPU 上, 主要工作为: 定义当下要构建世界的模型图元, 对 CPU 种的各个 Shader 进行编程和参数设定, 最后将渲染图元(rendering primitives)等信息传递给 GPU, 通过 GPU 处理显示在屏幕上\n 开发者通过程序对图元数据进行配置和调控, 由于可以对该阶段进行完全控制, 可以通过更改实现方法来改变性能 通常该阶段在几个并行处理器上执行, 称为超量体系(superscalar)结构 通常实现的方法有: 碰撞检测, 加速算法, 输入检测, 动画, 力反馈, 纹理动画, 变换仿真, 几何变形, 和一些不在其他阶段执行的算法 (如层次视锥裁剪等加速算法) 该阶段将摄像机位置, 光照和模型的图元数据输出到几何阶段  几何阶段(Geometry) Application Stage 结束后, GPU 获得 rendering primitives 和一些相关指令和参数进行处理, 首先会进入几何阶段, 几何阶段可以分为 Vertex Shading, Projection, Clipping 和 Screen Mapping4 个阶段\n顶点着色(Vertex Shadering) 该阶段主要任务是, 计算顶点的位置, 将其从模型空间转到视图空间\n 模型视点变换(Model to View Transform):  模型变换(model transform): 从model space到world space, 转到适合模型渲染的空间中 视图变换(view transform): 转换到观察空间(view space), 将相机放在原点, 进行视点校准(朝向 z 轴负方向, y 轴指向上方, x 轴指向右边)     顶点进行其他操作:  着色(shading): 确定材质上的光照效果, 过程涉及在对象上各个点计算着色方程(shading equation) 可以在顶点处存储各种材料数据(颜色, 向量, 纹理坐标, 法线, 颜色坐标或计算着色方程所需的其他信息) 对物体的外观进行建模, 得到每个对象的材质, 照射在对象光源效果的一些描述 计算完顶点对应的光照信息后作为光栅化阶段的输入进行处理    可选阶段: 曲面细分(Tesselation) 在 Dx11 被引入, 在已有图元基础上去增加更多的顶点, 形成更精细的模型, 通过 Tesselation, 原有的模型增加了大量 vertex, 再应用 Displacement Mapping(存储高度信息, 真正改变顶点位置), 改变每个顶点的高度信息, 增加模型细节\n具体工作流程有三个部分:\n Hull Shader: 可编程, 接收控制点信息, 与一些系数发送到 Domain Shader, 同时发送一些系数到 Tesselator Tesselation: 细分控制点信息 Domain Shader: 可编程, 将所有接收到的信息整合  可选阶段: 几何着色(Geometry Shader) 在 Dx10 被引入, 在图元外添加(tesselation 为图元内添加)额外的 vertex, 将原始图元转为新图元, 构建不一样的模型\n  粒子系统(Particle System)\n 常用来模拟一些不定形物体(火, 烟雾, 水, 云, 爆炸等), 通常这些物体在其它技术下难以实现 \u0026ldquo;粒子\u0026quot;可以分解为: 质量, 位置, 速度, 形状, 生命周期 根据需要的效果, 可以使用正态分布函数实现粒子系统, 可以给予一个初始化速度和生命周期, 如模拟瀑布, 每帧产出一个\u0026quot;水粒子\u0026quot;再初始化一个下降的速度(正态分布), 同时受到一个模拟风力的影响 通常粒子系统有两种实现方式:  Spirte(2D) particle systems Voxel (3D) particle systems      通过 Geometry Shader 实现粒子系统:\n 使用一个 vertex 代表一个粒子 在该阶段将每个 vertex 拓展成两个三角形以形成一个正方形 可以使用几何着色器来决定下一个粒子的位置, 新建一个 vertex    投影(Projection) 投影阶段决定屏幕具体可以投出什么内容\n 将视体变换到一个单位立方体内(规范立方体(Canonical View Volume, CVV, 对角顶点为(-1, -1, -1), (1, 1, 1)) 主要有两种投影方法: 正交投影(orthographic/parallel projection), 透视投影(perspective projection) 完成投影后, z 坐标将不会保存于得到的图片中, 实现了从 3d 转为 2d z 坐标信息仍会存储在 z-buffer 种, 用于后续使用  裁剪(Clipping) 去除相对于屏幕外的物体\n 只有当图元处于 CVV 中才需要将其发送到光栅化阶段 图元相对于 CVV 分三种情况: 完全位于内部(不处理), 部分位于内部(裁剪处理), 完全位于外部(直接丢弃)  屏幕映射(Screen mapping) 将之前步骤得到的坐标映射到对应的屏幕坐标系\n 首先进行平移, 再缩放 映射过程中 z 坐标不受影响 新的 x, y 坐标称为屏幕坐标系, 与 z 坐标一起进入光栅化阶段  光栅化(Rasterization)   从二维顶点的屏幕空间(包含深度值, 及相关着色信息), 到屏幕上的像素转换\n  由几何阶段确定屏幕上的顶点, 颜色, 纹理坐标后, 给每个像素(Pixel)正确配色, 绘制整幅图像\n  三角形设定(Triangle Setup)\n 计算三角形表面差异和其他相关数据, 将一个个图元组装起来, 连成线组装成三角形(或只是线) 该数据主要用于扫描转换(scan conversion), 和由几何阶段处理的各种着色数据插值操作所用 该过程在专门的硬件上执行    三角形遍历/扫描转换(Triangle Traversal/scan conversion)\n 进行逐像素检查操作, 即检查每个图元(三角形, 点, 线)覆盖了哪些像素(采样点) 对于有三角形部分重合的像素, 在重合部分生成片段(fragment) 每个三角形片段属性(片段的深度, 着色数据)均由其三个顶点插值生成 判断像素是否属于该图元, 通过设置多个采样点定位    像素处理阶段(Pixel Processing)   像素着色(Pixel Shading)\n 在可编程 GPU 进行 该阶段主要任务是, 将之前阶段获得各个图元对应的像素位置和相应信息, 为每个像素进行正确的着色 纹理贴图: 从顶点着色器中获得纹理的坐标, 去纹理单元中裁剪出这个图元对应的纹理, 再给每个像素复制 使用插值的着色数据作为输入, 输出一种或多种颜色信息到下一阶段    融合(Merging)\n 该阶段输入的每个 pixel 都有相应的颜色信息, 存储在 color buffer 上 融合的主要任务是合成当前存储于 buffer 中的片段信息整合, 得到具体的一帧图像信息 非完全可编程, 但高度可配置 常见的缓冲区有:  帧缓冲(frame buffer): 通常包含一个系统所具有的所有缓冲器(或是 color buffer 和 z-buffer 的组合) 颜色缓冲器: 颜色(RGB)的矩阵列, 每个像素的信息都存在颜色缓冲器中 深度缓冲(z-buffer): 负责可见性的处理, 通常通过 z-buffer 来实现 alpha通道(alpha channel): 和颜色缓冲器计算每个像素的不透明值, 在深度测试前传入片段中运行, 通常用于不影响深度缓冲的全透明片段处理 模板缓冲(stencil buffer): 记录所呈现图元位置的离屏缓存, 每个像素通常占用 8 位, 用于进行一些特效制作 累计缓冲(accumulation buffer): 用一组操作符对图像进行累积, 用于产生动态模糊(motion blur), 景深(depth of field), 后处理反走样(post-process anti-aliasing), 软阴影(soft shadows)等;      双缓冲(double buffering):\n 用于避免观察者感知到图元处理发送到屏幕的过程 屏幕绘制在后置缓冲器(backbuffer)中离屏进行 后置缓冲器不断与用于屏幕显示的前置缓冲内容进行交换(不影响显示时)    总结   一张图总结一下渲染管线流程:\n  Vulkan 的渲染管线流程:\n  D3D11 的渲染管线流程:\n  GPU 渲染管线工作流程 现代编程语言  现代着色阶段(Shader model 4.0, DirectX 10及以后)使用通用着色核心(common-shader core), 表明顶点, 片段, 几何着色器共享一套编程模型 目前着色语言都是 C-like, 如GLSL, CG, HLSL 被编译成独立于机器语言的汇编语言IL, 通常在驱动中转化成实际机器语言, 可以兼容不同硬件实现 IL 可以理解成定义一个着色语言编译器的虚拟机, 处理多种类型寄存器和数据源, 预编一系列指令处理器 很多图形操作使用短矢量(最高四位), 处理器拥有 4 路SIMD(single-instruction multiple-data, 单指令多数据)兼容性 每个寄存器包含四个独立的值, 32 位单精度浮点的标量和矢量是其基本数据类型, 也支持结构体, 数组和矩阵  矢量: 位置(xyzw), 法线, 矩阵行, 颜色(rgba), 纹理坐标(uvwq) 标量: 计数器, 索引, 位掩码    实现步骤概述  顶点着色前进行输入装配(Input Assembler)阶段, 将一些数据流组织在一起, 发送到管线  GPU 实现了几何和光栅化概念管线阶段, 步骤如下:\n顶点着色器(Vertex Shader): 完全可编程  顶点属性包括位置, 颜色, 法线, 纹理坐标 对每个顶点属性进行变换, 变形等操作, 提供修改/创建/忽略顶点相关属性的功能 不能创建和删除顶点, 一个顶点的结果不能传递到另一个顶点 每个顶点独立处理, 使得 GPU 上着色器处理器可以并行应用到传入的顶点流上 可以在这里进行光照计算, 由于精度不高通常在片段着色器中计算 该阶段顶点坐标必须完成顶点从模型空间转换到齐次裁剪空间(世界, 观察, 裁剪) 流输出(Stream output): Shader Model4.0以上支持, 顶点着色器除了将处理后的数据发送到光栅化阶段, 还可以输出到流(有序数组), 输出到流的数据可以通过管线回传, 允许迭代处理, 是和模拟流动的水和其他特效  曲面细分 (Teselation Shader): 可选  利用镶嵌化处理技术对三角面进行细分, 以此来增加三角面的数量 借助曲面细分的技术实现LOD机制 组成:  外壳着色器(Hull Shader): 可编程 镶嵌器(Tessellator): 由硬件管理 域着色器(Domain Shader): 可编程    几何着色器(Geometry Shader): 可选, 完全可编程  Shader Model 3.0以上支持 主要对输入图元(单个对象及相关的顶点)进行操作 允许 GPU 高效创建和销毁几何图元:  几何增长: 改变新传递的图元的拓扑结构 接受任意拓扑类型的图元, 输出点, 折线(line strip), 三角形条(triangle strips)   常见应用:  元球的等值曲面细分(metaball isosurface tessellation) 线段细分的分形(fractal subdivision of line segments) 布料模拟等    功能阶段  裁剪(Clipping): 可配置  可选运行的裁剪方式, 添加自定义的裁剪面   屏幕映射(Screen Mapping): 完全固定 三角形设定(Triangle Setup): 完全固定 三角形遍历(Triangle Traversal): 完全固定  像素/片段着色器(Pixel/Fragment Shader): 可编程  该着色器主要进行像素/片元的处理, 在每个片段上执行着色方程 常用来处理场景光照及相关(如阴影)的效果处理, 如凹凸纹理映射和调色 着色器调用的像素并非和屏幕像素一一对应, 如计算被遮挡的物体的片段 该着色器通常在最终合并阶段设置片段颜色进行合并, 深度值也可以在该着色器修改 SM4.0 中共有 16 个 4 维向量可以从顶点着色器传到像素着色器, 使用几何着色器时增加到 32 个  合并阶段(Merging): 可配置  将像素着色器中生成的各个片段的深度和颜色与帧缓冲结合在一起 除了进行合并操作, 还可以进行相关缓存的处理(z-buffer, Stencil等), 透明处理(Transparency), 混合(Blending), 合成(Compositing) 该阶段不可编程, 但是高度可配置, 可以设置颜色混合来执行大量不同操作:  Alpha 值的乘法, 加法, 减法的组合, 根据片段的 Alpha 值进行混合, 用来产生半透明的效果 最大值, 最小值, 按位逻辑运算   半透明的物体需要遵循画家算法进行绘制, 或使用顺序无关的半透明渲染技术(OIT)技术  ","description":"渲染管线流程","id":14,"section":"posts","tags":["cg"],"title":"渲染管线流程","uri":"https://npchitman.com/posts/render-pipline/"},{"content":"效果预览    Info Preview          介绍  对纯键盘操作进行优化 其他的发行版未测试, 理论上也适用 具体的系统环境参考图 1(Info)  安装方法 执行部署脚本 注: 脚本将所有的配置部署到相应的目录下, 为了安全性, 若文件存在则不会覆盖,\n若要使用安装脚本, 请备份好自己的配置再将其从相应的目录删除\n1 2 3 4 5  git clone https://github.com/npchitman/dot_files cd dot_files sh put.sh   安装字体  Fantasque: 非常好看的编程用字体 Font-Awesome: 图标, 可在这里查找  使用方法 快捷键  全部快捷键在 i3config 配置里, 举出一些例子  快捷菜单    按键 说明     Super + d 快捷启动应用   Super + Shift + d 应用菜单   Super + Shift + w 快捷启动站点   Super + shift + e 电源选项    音频控制  需要 playerctl 支持,\nspotify 下完美使用, 其他自行测试     按键 说明     Super + Shift + n/m 播放上一首/下一首曲子   Super + Alt + p 暂停/继续播放   Super + Alt + k/j 音量增加/减少   Super + Alt + m 静音/取消静音    其他    按键 说明     Super + Alt + w 随机壁纸与相应配色, 需要 pywal 支持   Super + a 快速截图, 需要 scort 支持    配置文件包含的应用 - config    应用名 说明     compton 独立合成管理器, 为 i3 提供淡入淡出, 阴影等效果   dunst 通知窗口   i3 i3 桌面配置   polybar 系统状态栏, 若要使用请参考 wiki   ranger tui 文件浏览器, 支持图片预览等功能   rofi 包含程序启动器, 电源菜单, 网站快捷打开菜单   termite 模拟终端   tilda 下拉式模拟终端   vimiv 类 vim 操作的图片浏览工具    - emacs   基于 redguardtoo/emacs.d\n的配置, 请参考文档\n  custom.el: 请参考 overide default setup\n  - nvim  使用 thinkvim 的配置 thinkvim.d: 参考 User Custom  快捷键绑定  下面是个人自定义快捷键, 关于 thinkvim 默认的快捷键参考 leaderkey.vim 和 motion.vim \u0026lt;LocalLeader\u0026gt;为分号;     快捷键 说明     H/L 移动到改行句首/尾   Ctrl g 映射为 Esc 键   \u0026lt;LocalLeader\u0026gt; cc/cu 注释/取消注释   \u0026lt;LocalLeader\u0026gt;\u0026lt;LocalLeader\u0026gt; k/j 向上/下快速跳转光标   \u0026lt;LocalLeader\u0026gt; q 退出 vim    - xorg X 系统相关配置, 下面给出相关 wiki\n  Xresources\n  Xinitrc\n  Xprofile\n  - zsh zsh 相关配置, 参考 ohmyzsh\n zprofile zshrc  ","description":"arch linux, i3wm","id":15,"section":"posts","tags":["linux"],"title":"Linux Ricing 1.0","uri":"https://npchitman.com/posts/linux_ricing/"}]