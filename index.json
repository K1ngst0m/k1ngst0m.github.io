[{"content":"正向渲染 (Forward Rendering/Shading)   根据所有光源照亮一个物体, 之后再渲染下一个物体\n  传统正向渲染思路: 先着色, 再进行深度测试\n  复杂度与光源关系很大, n个受到光源影响的物体, m个光源, 复杂度为O(m*n), 比较适合户外光源较少的情形\n  程序要对每个光源需要渲染的片段进行迭代, 如果旧的片段被新的覆盖(深度测试), 最终不显示, 就造成了浪费\n  实现简单, 影响性能较大\n  使用延迟渲染(Deferred Rendering)来解决大量光源的场景\n  延迟渲染 (Deferred Rendering)  基本思想: 在二维空间进行光照计算(先深度测试, 再着色) 几何缓冲区(G-buffer, Geometric Buffer): 延迟渲染将所有物体先绘制到这里, 再逐光源进行着色, 避免深度测试后丢弃的片元被计算 对于O(m*n)的正向渲染(n个物体, m个光源), 标准的延迟渲染为O(m+n): m次物体绘制 + n次光源着色  几何缓冲区 (G-Buffer)   G-Buffer用于存储像素对应的位置(Position), 法线(Normal), 漫反射颜色(Diffuse Color)等, 根据这些信息, 在二维空间中进行光照处理\n  G-Buffer直接存储位置, 颜色, 法线等对象到帧缓存中, 过程几乎不消耗处理时间, 非常高效\n  深度测试已经将不需要的信息消除, 只用渲染需要的信息, 省下很多无用的调用\n  优化空间大, 能够渲染更多的光源\n  处理过程:\n 几何处理阶段(Geometry Pass): 获取对象的各种几何信息, 将第二步所需的各种数据存储(渲染)到多个G-buffer中 光照处理阶段A(Lighting Pass): 渲染屏幕大小的二维矩形, 使用第一步在G-buffer中存储的数据对此矩阵进行着色计算(计算过程与正向渲染一样, 输入变量的位置变为G-buffer)    优点:\n 复杂度O(m + n) 只渲染可见像素 使用更少的shader 后处理支持好 大光源下优势明显    缺点:\n 内存开销较大 读写G-buffer的内存带宽用量是性能瓶颈 对透明物体渲染需要结合正向渲染 对MSAA支持不友好, 需要开启MRT    改进方法 主要有两种方法:\n 延迟光照(Light Pre-Pass, Deferred Lighting): 最小化G-Buffer数据结构 分块延迟渲染(Tile-Based Deferred Rendering): 将多个光照组合处理  延迟光照(LightPre-Pass/Deferred Lighting)  减少G-buffer开销(reduce G-buffer overhead) 对MSAA使用有利(使用z值和normal, 很容易找到边缘) 具体思路:  几何阶段(Geometry Stage): 渲染场景中不透明(opaque)的几何体, 将法向量n和镜面扩展因子(specular spread factor)m写入缓冲区, 即n/m-buffer, 类似于G-buffer, 包含信息更小更轻量, 适合输出单个缓冲区, 不需要MRT支持 光照阶段(Lighting Stage): 计算漫反射和镜面着色方程, 将结果写入不同的漫反射和镜面反射累积缓冲区(Light Accumulation Buffer), 可以在单独的pass中完成(使用MRT)或者两个, 环境光照可以使用full-scene pass进行计算 着色阶段(Shading Stage): 对场景中不透明几何体进行第二次渲染, 从纹理中读取漫反射和镜面反射值, 对前面步骤中漫反射和镜面反射累积缓冲区进行调整, 将最终结果写入颜色缓冲区, 若上阶段没有处理环境光, 则该阶段处理, 只需计算累积缓冲区的信息    分块延迟渲染(TBDR, Tile-Based Deferred Rendering)   传统DR的问题: 每个光源即使重叠, 仍是独立进行, 会重复读取G-buffer中相同位置的数据, 计算后以相加混合方式写入颜色缓冲, 光源数量会影响内存带宽用量\n  TBDR思想: 将屏幕划分成细小的栅格(如32x32像素为一个Tile), 计算每个分块受到哪些光源影响, 将光源索引存储在分块光源列表里, 最后逐个方块进行着色, 对每像素读取G-Buffer和光源列表及相关信息, 大致步骤如下:\n 将屏幕分成一个个小块tile 根据这些Depth求得每个tile的bounding box 对每个bounding box和light进行求交, 得到与该tile作用的light序列 根据得到的序列计算tile的光照效果    G-buffer数据只会被读取一次, 写入color buffer也是1次, 大幅降低内存带宽用量\n  compute shader: 在渲染管线外进行, 通常处理大量并行计算, 节省CPU资源\n  该方法需要进行光源剔除(light culling, 计算光源影响哪些分块), 可以在CPU或GPU(通常使用compute shader)中实现, 使用GPU更快, 减少CPU-GPU传输, 并且可以计算每个分块的深度范围(depth range), 更有效地剔除\n  合理分摊开销, 性能优于Light Pre-Pass\n  ","description":"延迟渲染","id":6,"section":"posts","tags":["cg"],"title":"延迟渲染技术","uri":"http://npchitman.github.io/posts/deferred-rendering/"},{"content":"锯齿, 抗锯齿 锯齿   奈奎斯特极限(Nyquist Theorem): 采样频率是原始信号中最高频率的两倍\n  根本原因是因为采样分辨率不足, 要采样的最高频率超过奈奎斯特极限(Nyquist Limit), 产生锯齿(jaggies)\n 采样频率: 显示器给定的分辨率 采样对象频率: 显示的图像的最高频率    锯齿按表现分类:\n 几何锯齿(Geometric Aliasing): 光栅化采样不足导致, 体现几何边缘的锯齿现象 着色锯齿(Shading Aliasing): 渲染(如光照计算)的采样不足导致, 体现在画面中的部分像素点的闪烁或噪点    最好的解决方法是提高采样频率, 即显示分辨率, 但多数情况不能满足, 故需要使用其它技术\n  抗锯齿   抗锯齿(AA, anti-aliasing), 也称为反走样, 边缘柔化, 消除混叠, 抗图像折叠有损, 用于消除显示器输出画面中物体边缘出现锯齿的技术\n  抗锯齿分类:\n  空域抗锯齿技术(柔化边缘): 通过超采样几何边缘达到模糊边缘的效果, 理论上通过低通滤波抑制几何边缘高频信息, 只能缓解几何锯齿, 对着色锯齿无效\n  帧间抗锯齿技术(分摊采样压力): 通过加权混合相邻多帧达到抗锯齿效果, 理论上解释就是将计算量分摊(Amortized)至多帧的超采样(Super-Sampling), 能够有效缓解几何锯齿和着色锯齿, 通常需要修正历史帧像素, 否则会出现拖影\n  基于图像后处理\n  增加采样数\n  基于深度学习\n    帧间相关性(frame-to-frame coherence): 相邻的两帧画面通常是平滑过渡的, 较少出现突变\n  量化抗锯齿技术的好坏可以从效果和消耗出发\n  超级采样抗锯齿 SSAA (Super Sampling)  比较早期的抗锯齿算法, 比较消耗资源 原理是先将图像映射到缓存并放大, 再用超级采样把放大的图像像素进行采样, 通常选取2/4个临近像素, 混合后生成最终像素 通常使用两种超级采样法:  顺序栅格超级采样 (OGSS, Ordererd Grid Super-Sampling), 采样时选取2个临近像素 旋转栅格超级采样 (RGSS, Rotated Grid Super-Sampling), 采样时选取4个临近像素   全场景抗锯齿(FSAA, Full-Scene Anti-Aliasing): 以较高的分辨率对场景进行绘制, 然后对相邻的采样样本进行平均  多重采样抗锯齿 MSAA(Multi Sampling)  特殊的超级采样抗锯齿(SSAA), 来自于OpenGL MSAA只对z-buffer和stencil-buffer中的数据进行SSAA的处理, 即只对多边形边缘进行处理 相比SSAA资源消耗大大减弱(通常还有GPU支持加速), 但画质表现会损失一些 MSAA对于半透明物体, 边缘不明确或者非常复杂的物体(草丛, 铁丝网)的处理比较力不从心 不适合延迟渲染(光栅化信息存在GBuffer), 适用在前向渲染中  子像素增强抗锯齿(SMAA Enhanced Subpixel Morphological)  后处理抗锯齿 与FXAA类似, 性能消耗小, 比FXAA清晰 处理流程建立在MLAA算法上 动态画面上效果不好, 可以和TAA同时开启  覆盖采样抗锯齿 CSAA(Coverage Sampling)  在MSAA基础上进一步节省显存使用量及带宽 CSAA将边缘多边形里需要取样的子像素覆盖掉, 把原像素坐标强制安置在硬件和驱动程序预先算好的坐标中, 相比于MSAA能够最高效率地执行边缘取样, 16xCSAA性能下降相当于4xMSAA, 效果相当于8xMSAA  高分辨率抗锯齿 HRAA/Quincunx (High Resolution)  出自Nvidia, 五点梅花状采样, 其中四个样本在像素单元的角上, 最后一个在中心  可编程过滤抗锯齿 CFAA (Custom Filtter)  扩大取样面积的MSAA, 可以更灵活选取对抗锯齿影响较大的像素进行缩放, 以较少的性能牺牲换取平滑效果, 从而减小显卡资源消耗  形态抗锯齿 MLAA (Morphological)  出自AMD, 完全基于CPU处理的后处理抗锯齿方案 MLAA将跨越边缘像素的前景和背景色进行混合, 用第二种颜色填充该像素, 更有效改进图像边缘的变现效果 资源消耗较大 仅使用颜色辨识, 无法辨识哪些边缘需要进行计算, 导致文字, 表格受到影响  快速近似抗锯齿 FXAA (Fast Approximate)  传统MSAA的一种高性能近似, 可以同时开启, 是后处理抗锯齿 FXAA是一种单程像素着色器, 相比MLAA不依赖于GPU的API, 兼容不同硬件 性能比MLAA好, 画面接近于MSAA 会出现字体破坏情况, 但不会造成镜面模糊和亚像素模糊(闪烁现象/时间性锯齿)  TAA (Temporal)   样本点分摊在时域上的超采样\n  能在延迟渲染上使用\n  以后处理的方式融入渲染流\n  相机抖动: 相机随时间抖动时, 引入了额外的子像素信息, 通过融合子像素获得时域上的超采样效果, 使得静态场景中与SSAA效果一致\n  实现细节\n 开始移动相机: 利用图形学的Motion Vector计算像素点当前帧和上一帧的移动 采样出现的问题: 移动相机后, 历史像素上, 因为当前画面的一个矩形像素点不可能刚好映射到上一帧的矩形像素, 需要引入插值来近似上一帧颜色, 导致像素模糊 遮挡/动态物体: 即历史像素与当前像素毫无关联的情况, 时域EMA加权给历史像素很大的权重, 导致历史画面残留在当前画面上, 需要丢弃无关样本, 解决方案是使用颜色空间的Clipping, 计算当前像素机器邻域的均值和方差, 若历史颜色不在这个范围内, 则丢弃, 丢弃后的颜色与当前颜色重新进行加权 物体边缘: 单纯使用Motion Vector, 仍会出现锯齿, 解决方式是取Motion Vector3x3邻域最长的向量 闪烁: 不收敛, 闪烁, 子像素出现在最高票信息中, 混合过程中, 少量高频信号极大影响混合后效果, 导致像素闪烁    时间性抗锯齿 TXAA (Temporal)  TAA + MSAA, 通过引入额外的深度信息来实现延迟渲染中使用MSAA TXAA还能对帧之间的整个场景进行抖动采样, 减少闪烁(时间性锯齿) TXAA目前有2X和4X两种模式, 2X效果堪比8X MSAA, 性能减少相当于2X MSAA  多帧采样抗锯齿 MFAA (Multi-Frame)  MSAA的优化版, 近乎相同效果同时提升性能 只有Maxwell架构的GPU显卡才能使用 同样开启4倍效果时  MSAA针对每个边缘像素周围4个像素进行采样 MFAA采用交错的方式采样边缘某个像素周围的两个像素    ","description":"常见抗锯齿技术分类与原理","id":7,"section":"posts","tags":["cg"],"title":"抗锯齿类型总结","uri":"http://npchitman.github.io/posts/anti-aliasing/"},{"content":"游戏渲染优化的方向: 更高的FPS, 更高的分辨率, 能够渲染更多的物体, 更真实的场景, 实现更高的复杂度\n游戏开发中的渲染加速算法 常用空间数据结构(Spatial Data Structures) 空间数据结构是将几何体组织在N维空间的一系列数据结构, 可以用于很多实时渲染的加速查询, 如:\n 场景管理 裁剪算法 相交测试 光线追踪 碰撞检测等  空间数据结构的组织通常是层次结构(最顶层嵌套递归包含之下的层次), 访问复杂度可以达到O(logn), 但是构造开销较大, 通常需要作为一个预处理的过程来完成\n常见的空间数据结构有:\n  层次包围盒(BVH, Bounding Volume Hierarchies)\n 利用体积略大的几何特征简单的包围盒近似描述复杂的几何对象, 从而只需对包围盒重叠的对象进行进一步相交测试 通过构造树状层次结构, 可以越来越逼近对象的几何模型, 直至几乎完全获得对象几何特征 层次包围体通常用于层次视锥裁剪, 场景及层次树状结构进行组织: 根节点(root), 内部节点(internal), 叶子节点(leaves)包含需渲染的几何体    二叉空间分割树(BSP, Binary Space Partition Trees)\n 基于空间细分(Space Subdivision)的数据结构, 可任意细分 BSP递归地将空间使用超平面划分为凸面体的几何, 使用BSP树实现:  每个节点表示一个有向超平面, 左子树为前向(front), 右子树为背向(back) 如果使用一种特定方式遍历, 树的内容可以从任意角度进行前后排序: 可以近似轴对齐, 精确对齐多边形BSP   类似于画家算法, BSP方便将表面从后往前渲染出来, 适用于场景固定不变, 仅视点移动的情况 BSP树有两大类别: 轴对齐(Axis-Aligned)和多边形对齐(Polygon-Aligned)    八叉树(Octrees):\n 基于空间细分, 均匀分割 每个节点表示正方体的体积元素 每个节点有八个子节点加起来等于父节点的体积, 中心点为节点的分叉中心 这种分割方式可以得到比较规则的结构, 使得查询更加高效 松散八叉树(Loose Octrees): 基本思想和普通八叉树一样, 每个长方体大小选中比较宽松, 使用松散八叉树更加灵活(一个物体处于边缘时)    四叉树(QuadTree):\n 相对于八叉树, 将二位正方形空间分割成四个小正方形    kd树(k-dimensional tree)\n 对k维空间中的实例点进行存储以便快速检索的树形结构 主要应用于多维空间关键字搜索    场景图(Scene Graphs)\n 存储场景中复杂多样的几何体(几何图形, 动画, 可见性, 其他元素的控制) 可以通过纹理, 变换, 细节层次, 渲染状态(如材质属性), 光源等合适的内容进行扩充, 以一颗深度优先遍历来渲染整个场景的树来表示    裁剪技术 (culling) 裁剪操作可以发生在渲染管线的任意阶段, 可以预处理, 通过硬件实现, 在CPU中配置, 裁剪通常可以使用几何计算来实现, 也可以使用帧缓冲中的内容, 理想的裁剪算法预期是只发送图元中通过管线的精确可见集(Exact Visible Set, EVS)\n  背面裁剪(Backface Culling)\n 对于不透明的物体, 将背向视点的物体删除, 无需光栅化 聚集背面裁剪(Clustered Backface Culling): 一次性对于一组物体进行背面裁剪 确定多边形是否背向的方法: 在屏幕或视点空间中, 通过判断顶点排列方向(顺时针或逆时针, 向量叉乘)    视锥裁剪(View Frustum Culling), 层次视锥裁剪(Hierarchical View Frustum Culling)\n 将视锥之外的多边形删除 计算在CPU上进行, 排除的物体不需要通过管线中的几何和光栅化阶段 利用空间数据结构可以分层进行裁剪    遮挡剔除(Occlusion Culling)\n 将被其他物体遮挡的物体进行删除 算法两种主要形式: 基于点的遮挡裁剪, 基于单元的遮挡裁剪 常见的遮挡剔除算法(Occlusion Culling Algorithm):  硬件遮挡查询(Hardware Occlusion Queries): 通过硬件查询一组多边形是否可见(通常是复杂物体或包围体), 使用z-buffer 层次Z缓冲(Hierarchical Z-buffering): 用八叉树来维护场景模型, 将画面的z-buffer作为图像金字塔(Z-pyramid), 作为算法的遮挡表示 遮挡地平线(Occlusion Horizons) 遮挡物收缩(Occluder Shrinking)      入口裁剪(Portal Culling):\n 室内场景通过每个入口(门或窗户等)进行视锥裁剪, 遍历入口时减小视锥    细节裁剪(Detail Culling):\n 牺牲质量换取速度 当视点处于运动时, 微小细节对于渲染出的图像贡献甚微, 减小这些物体的细节    层次细节技术(LOD, Level of Detail)  LOD切换技术:  Discrete Geometry LODs Blend LODs Alpha LODs CLODs and Geomorphic LODs   LOD选取技术:  Range-Based Project Area-Based Hysteresis    大型模型的渲染(Large Model Rendering)  点渲染(Point Rendering)  渲染管线优化方法 优化的过程可以归纳为以下基本的确认和优化的循环:\n 定位瓶颈: 对于管线的每个阶段, 若改变负载或计算能力导致性能发生改变, 则为一个瓶颈 进行优化: 指定发生瓶颈的阶段, 减小该阶段负载, 直到性能不再改善, 或者达到要求位置 重复1, 2  如果无法对最慢的阶段优化, 可以增加其他部分的负载, 达到更好的效果(不等白不等)\n瓶颈定位策略   可以使用profile工具了解哪些API调用耗费高, 但不能准确知道哪阶段减慢速度\n  采用基于工作量变化的控制变量法: 设置一系列测试, 每个测试减少特定阶段执行的工作量, 其中一个测试导致FPS增加, 则已经达到瓶颈阶段\n  或使用上述方法的排除法: 不降低工作量的前提减少其他阶段的工作量, 如果性能没改变, 则瓶颈为该阶段\n  管线每个阶段都依赖于GPU频率(GPU Core Clock, GPU Memory Lock), 可以使用PowerStrip减小相关时钟速度, 观察性能变化\n  光栅化阶段瓶颈定位 几何阶段瓶颈定位 应用程序阶段瓶颈定位 渲染管线的优化策略 ","description":"性能优化","id":8,"section":"posts","tags":["cg"],"title":"游戏开发中渲染性能的优化","uri":"http://npchitman.github.io/posts/optimization/"},{"content":"纹理贴图是使用图像, 函数及其他数据来源来改变物体表面外观的技术\n纹理管线 The Texturing Pipeline 纹理管线是单个纹理应用纹理贴图的详细过程\n投影方程(projection function) 通过投影方程运用空间中的点, 得到参数空间值(parameter-space values)\n映射函数(correcponder function) 通过映射函数将参数空间值转到纹理空间(texture space location)\n获取纹理空间中相应的值(Obtain value) 使用纹理空间值获得相应的值, 可以使用图像纹理的数组索引来检索像素值\n值变换函数(value transform function) 使用值变换函数对检索结果进行替换\n最后使用得到的新值来改变表面属性(材质, 着色法线等)\n纹理类型 三维纹理/体纹理(3D/Volume Texture)  传统二维纹理(2D texture)在逻辑上的扩展 二维纹理是一张简单的位图图片, 用于为三维模型提供表面顶点值 一个三维纹理可以认为由很多二维纹理组成, 用于描述三维空间数据的图片, 通过三维座标访问 体纹理的优势:  直接用作纹理座标, 避免二维纹理发生的变形和接缝问题 使用三维纹理表示木材或大理石的体积结构, 看起来更逼真    立方体贴图 (Cube Map)   使用6幅二维纹理图像构成以原点为中心的纹理立方体:\n 每个2D纹理是一个立方体的一个面 每个片段纹理座标(s, t, r)被当作方向向量看待 每个纹素(texel)都表示从原点看到的纹理立方体上的图像    Cube Map支持双线性滤波和mip mapping, 可能会出现接缝处问题, 需要处理其他面的相邻样本, 每个纹素的角度范围等\n  程序贴图纹理 (Procedural Texturing)  通常用于离线渲染程序, 实时渲染更多使用图像纹理 通过计算机算法生成, 用于表现一些自然元素的真实表面(木材, 大理石, 花岗岩, 金属, 石头等) 通常使用分形噪声(fractal noise)和湍流扰动(turbulence functions)的随机性函数来生成纹理  凹凸贴图 (Bump Mapping) 通过纹理方法来产生凹凸不平的视觉效果, 主要原理是通过改变光照方程中的法线(不是表面的几何法线), 或对每个带渲染的像素计算照明前加上一个从高度图中的扰动, 模拟凹凸不平的视觉特征, 如褶皱, 波浪等\n 原理:  常见的凹凸贴图有:\n 凹凸贴图(Bump Mapping): 计算vertex光强时, 不直接使用该原始向量, 而是在原始法向量上加一个扰动得到修改法向量, 经过光强计算得到凹凸不平的表面效果 移位贴图(Displacement Mapping): 直接作用于vertex, 根据移位贴图中对应vertex的像素值, 使vertex沿法向量移动, 产生真正的凹凸表面 法线贴图(Normal Mapping): 需要法向量信息, 可由高度贴图得到, 通过rgb通道存储法向量, 利用该信息计算光强, 产生凹凸阴影的效果(不增加多边形), 不发生自遮挡 视差贴图(Parallax/Virtaul Displacement Mapping): 以视线和height map计算比较陡峭的视角给vertex较多的位移, 较平缓的视角给vertex较少的位移 浮雕贴图(Relief Mapping): 能发生自遮挡, 闭塞的效果, 相当于\u0026quot;在Shader里做光线追踪\u0026quot;, 算法相对复杂  纹理缓存 (Texture Caching) 常见的纹理缓存使用策略:\n  最近最少使用策略(LRU, Least Recently Used)\n 加载到图形加速器中的每个内存都被给出一个时间戳, 用于最后一次访问已渲染图像时 当需要空间来加载新纹理时, 首先卸载最旧时间戳的纹理 可设置优先级: 如果两个纹理的时间戳相同, 优先卸载较低的纹理, 可以避免不必要的纹理交换    最近最常使用策略(MRU, Most Recently Used)\n 当前帧载入纹理时会发生抖动(Thrashing)的情况, 不适合使用LRU(每帧画面中会对每张纹理图像进行交换) 使用MRU策略, 直到画面中没有纹理交换为止, 切换到LRU    预取策略(Prefectching)\n 瓦片地图(tiles): 对于大数据纹理(如飞行和地形模拟系统), 传统方法将其分解成更小的硬件可以处理的tiles 裁剪图(clipmap): 将整个数据集视为mipmap; 对于任何特定视图, 只需mipmap较低级别的一小部分即可; 需要GPU支持Dx10    纹理压缩 (Texture Compression)  固定速率纹理压缩(Fixed-rate Texture Compression): 通过硬件解码压缩处理, 可以使用更少的纹理内存, 从而增加有效的高速缓存大小  硬件上实现较昂贵 DxTC / BC(Block Compression, Dx10): Dx的标准压缩模式, 使用S3TC(S3 Texture Compression)方法, 通过创建一个固定大小, 具有独立的编码片段, 解码简单, 速度快, 每个压缩图片都可以单独处理, 无共享查找表(look up tables), 简化过程    ","description":"纹理贴图相关技术","id":9,"section":"posts","tags":["cg"],"title":"纹理贴图相关技术","uri":"http://npchitman.github.io/posts/texturing/"},{"content":"透明渲染算法 常见的透明渲染算法有两种\nScreen-Door Transparency  阿尔法覆盖(alpha to coverage) 使用棋盘格填充模式来绘制多边形 每隔1个像素绘制一点来绘制会使后面的物体部分可见, 由于屏幕上像素比较紧凑, 不会露馅 优点: 可以任意时间和顺序绘制物体, 不需要特殊的硬件支持 缺点: 透明效果在50%的时候最好, 不易于控制, 屏幕中的每个区域只能绘制一个透明物体  Alpha混合 (Alpha Blending)  Alpha值用于表示透明度, 用来混合源像素和目标像素 从渲染管线接收像素的RGBA + z-buffer值来绘制  透明排序  需要将物体排序才能正确地绘制到场景中  深度缓冲 (Z-Buffer)  主流选择 深度缓冲可在硬件或软件中完成, 是可见性问题的一个解决方案 每个像素只存储一个对象, 重叠时透明对象后边的可见对象不能存储, 无法显示 使用A-buffer解决该问题, A-buffer具有深度像素(deep pixel), 可以在单个像素中存储一系列呈现在所有对象之后被解析为单个像素的多个片段  画家算法 / 优先填充算法 (Painter\u0026rsquo;s Algorithm)  先绘制远的场景, 再绘制近的场景覆盖 首先将场景中多边形根据深度进行排序, 按照顺序进行描绘 较复杂的场景(三角形覆盖)无法解决  加权平均算法 (Weighted Average)  使用简单的透明混合公式来实现无序透明渲染  深度剥离算法 (Depth Peeling)  对深度值进行排序 标准深度检测, 将Z值最小的点输出到屏幕上 进行多遍渲染, 每个顶点深度值与之前的深度值进行比较, 凡是小于等于第一遍得到的z值, 将其剥离  ","description":"透明物体渲染及排序算法","id":10,"section":"posts","tags":["cg"],"title":"透明渲染与排序","uri":"http://npchitman.github.io/posts/transparency/"},{"content":"核心 微平面理论(Microfacet Theory)  将物体表面建模成无数微观尺度上有随机朝向的理想镜面反射的小平面(microfacet) 实际PBR工作流中, 微平面通过粗糙度贴图或高光贴图来表示 微观尺度上, 表面越粗糙反射越模糊, 越光滑反射越集中 到达微观尺度后任何平面都可以用称为微平面的细小镜面来进行描绘 用统计学的方法估算微平面粗糙程度  半程向量(Halfway Vector): 位于光线向量l和视线向量v之间的中间向量 用基于一个平面的粗糙度(Roughness)来计算出半程向量的方向与微平面平均取向方向一致的概率    能量守恒(Energy Conservation)   入射光线能量 \u0026gt;= 出射光线能量\n  随着粗糙度上升, 镜面反射区域面积增加, 平均亮度下降\n  出射光线能量不能超过入射光线能量 (发光面除外)\n  镜面反射光照 (反射部分): 光线不进入平面直接反射的光线\n  漫反射光照 (折射部分): 光线进入表面被吸收的光线\n 光线与粒子碰撞后吸收光线所携带的一部分或是全部能量, 转为热量 并非所有能量会被全部吸收, 光线会继续沿着随机方向发散, 再和其他粒子碰撞直至能量完全耗尽或者再次离开这个表面 光线脱离物体表面后将会协同构成该表面的(漫反射)颜色 PBR对漫反射进行简化, 假设平面上每一点所有折射光都会被完全吸收而不会散开 保留次表面散射(Subsurface Scattering)的着色器能更好地显示皮肤, 大理石, 蜡质等类视觉效果    金属 (Metallic) 表面的反射与非金属(介电质Dielectrics)不同:\n 金属反射原理与折射原理相同 金属不会显示漫反射颜色 (所有折射光会被直接吸收而不会散开, 只留下反射光)    反射光与折射光互斥, 光线被反射无法被吸收, 折射光余下的进入表面中的能量正好是计算完反射后余下的能量\n  菲涅尔反射(Freshnel Reflection)  表示观察看到的反射光线的向量与视角相关的现象 光线以不同角度入射会有不同反射率, 掠射角度(90)下反射率最大 F0: 平行于表面法向量入射的菲涅尔反射值, 任意角度的菲涅尔反射可由F0和入射角度计算得出 光线对于不同物质有不同的反射率, 非金属F0: 0.02~0.04, 金属F0: 0.7~1.0  线性空间光照(Linear Space Lighting)  线性(向量)空间: 数字化的颜色和光照强度进行相加相乘计算的结果依然能与真实的结果一致 伽马矫正(gamma correction):  对图像进行非线性处理 具体实现是对图中每个像素做一次幂函数运算 图片文件夹存储的都是伽马纠正过的颜色值   PBR将贴图和颜色去除伽马纠正从伽马空间转换到线性空间, 再传递给着色器进行光照计算 线性空间下渲染管线流程: 去除伽马纠正-\u0026gt;着色-\u0026gt;伽马纠正-\u0026gt;显示 颜色值的计算和操作必须在线性空间中执行 描述物体表面属性的贴图(如粗糙度, 高光贴图, 金属贴图)必须保证是线性空间  色调映射/复制(Tone Mapping/reproduction)  表示以感知上令人信服的方式将HDR场景的强度值转换为显示强度的过程(将宽范围光照级别拟合到屏幕的有限色域的过程) 基于HDR渲染出来的亮度值会超过显示器能显示的亮度, 需要使用色调映射转为LDR(显示器能正常显示)  物质的光学特性(Real-World Measurement Based Substance Properties)  物质分为三大类: 绝缘体(Insulatiors), 半导体(semi-conductors), 导体(conductors) 渲染和游戏通常只关注导体和绝缘体 菲涅尔反射率代表材质的反射颜色和强度, 是真实世界的核心测量数值 非金属反射颜色: 单色/灰色镜面反射颜色(单个float) 金属反射颜色: 彩色镜面反射(RGB)  光照与材质解耦(Decoupling of Lighting and Material)  保证场景中所有对象有视觉一致性, 相同光照可以应用于所有物体和材质, 无需传统光照模型的额外调整, 提升美术工作效率  光学 (Optics) 几何光学/射线光学 (Geometrical Optics) 光与介质边界交互原理 一束光射到物体表面时, 由于物体表面与空气两种介质之间折射率的快速变化, 光线会发生反射和折射:\n  反射(Reflection):\n 光线在两种介质交界处的直接反射, 即镜面反射 镜面反射占入射光线的比率由菲涅尔方程计算    折射(Refraction): 从表面折射入介质的光, 会发生吸收(absorption)和散射(scattering), 介质的整体外观由散射和吸收特性决定\n  散射(Scattering): 由观察尺度划分\n 漫反射(Diffuse): 观察像素大于散射距离 次表面散射(Subsurface Scattering): 观察像素小于散射距离 透射(Transmission): 入射光经过折射穿过物体后的出射现象, 为次表面散射的特例    吸收(Absorption): 具有复折射率(complex number)的物质区域会引起吸收\n  光与不同物质交互 根据材质光学特性分为金属和非金属:\n   类型 反射 折射(散射) 折射(吸收)     金属 为三通道颜色 几乎无散射 立刻被自由电子吸收   非金属(均匀介质) 单通道颜色 无散射 无折射率变化   非金属(非均匀 - 浑浊介质) 单通道颜色 弱散射, 方向略微随机化 \u0026mdash;   非金属(非均匀 - 半透明介质) 单通道颜色 强散射, 方向完全随机化 \u0026mdash;   非金属(非均匀 - 不透明介质) 单通道颜色 强散射, 方向完全随机化 \u0026mdash;      金属(Metal)\n 外观主要取决于镜面反射, 折射的光线几乎全被自由电子吸收, 且不存在散射 反射颜色为三通道颜色    非金属(No-Metal): 即电介质(Dielectric), 整体外观主要由吸收和散射的特性组合决定\n 反射(Reflection): 单通道颜色(R=G=B) 折射(Refraction): 整体外观由散射和吸收的特性组合决定, 不同介质类型散射和吸收特性:  均匀介质(Homogeneous Media): 主要为透明介质, 无折射率变化, 不存在散射, 光直线传播不改变方向, 强度会通过吸收减少 非均匀介质(Nohomogeneous Media): 通常可以建模为具有嵌入散射粒子的均匀介质, 具有折射率变化  浑浊介质(Cloudy Media): 具有弱散射, 散射方向略微随机化, 根据组成不同具有复数折射率的区域引起吸收 半透明介质(Translucent Media): 具有强散射, 散射方向完全随机化, 根据组成不同具有复数折射率的区域引起吸收 不透明介质(Opaque Media): 与半透明介质一致        半导体(semiconductor) : 综合金属和非金属的特性\n  真实世界的材质渲染 辐射度量学 (Radiometry)  辐射度量学是用来度量电磁场辐射(包括可见光)的手段, 多种辐射度量(radiometric quantities)用来测量曲面或某个方向的光, 其中辐射率(Radiance)与反射率方程有关  常见辐射量单位    物理量 说明     辐射能(Radiant energy) 能量   辐射通量/功率(Radiant flux) 单位时间的辐射能量   辐射度(Radiosity) 表面出射和反射的辐射通量总和   辐射出射度(Radiant exitance) 表面出射的辐射通量   辐射强度(Radiant intensity) 单位立体角的辐射通量   辐射率(Radiance) 单位立体角的单位投射表面的辐射通量   辐照度(Irradiance) 入射表面的辐射通量    辐射率(Radiance)   辐射率用来量化单一方向发射来的光线大小或强度, 辐射度量学上表示一个区域平面上光线总量的物理量, 受到入射(Incident)光线与平面法线间夹角的余弦值影响\n  组成辐射率的物理变量:\n  辐射通量/功率(Radiant flux):\n 表示一个光源所输出的能量; 可以看作该光源包含各种波长的一个函数, 辐射通量计算该函数的总面积; 以瓦特为单位, 通常使用RGB来作为辐射通量的表示, 对于视觉上的影响可以忽略;    立体角(Solid Angle):\n 投射到单位球体上的一个截面的大小或者面积 将立体角和面积看作无穷小(面转为点, 立体角转为方向向量), 就可以用辐射率表示单束光线穿过空间中的一点    辐射强度(Radiant Intensity):\n 表示单位球面上, 一个光源向每单位立体角所投送的辐射通量 用于计算单位面积(立体角)能量大小      渲染方程 反射率方程   渲染方程(Render Equation):\n 描述了光能在场景中的流动, 目前用来模拟光视觉最好的模型 物理基础是能量守恒定律    反射率方程(The Reflectance Equation):\n 基于PBR的渲染方程的特化版本(近似)    双向反射分布函数BRDF BRDF介绍 (BRDF, Bidrectional Reflective Distribution Function)\n  BRDF用于描述光如何从给定的两个方向(入射光方向l和出射光方向v)表面进行反射的函数\n  定义：出射辐射率的微分(differential outgoing radiance)和入射辐照度的微分(differential incoming irradiance), 即辐射率(radiance)和辐照度(irradiance)之比\n  基于表面材质属性对入射辐射率缩放或加权\n  输入: 光的入射, 出射方向, 平面法线, 微平面粗糙度\n  输出: (近似) 每束光线 对一个材质平面 最终反射的光线的权\n (能量守恒) 完全光滑情况, 所有入射光线BRDF 返回0.0, 只有一束与出射光线拥有相同的角度光线会得到1.0返回值    遵循能量守恒定律\n  采用入射和出射方向作为参数的Blinn-Phong也认为是一个BRDF, 由于不遵循能量守恒, 不是PBR\n  实时渲染管线通常使用 Cook-Torrance BRDF\n  BxDF:\n 对于BRDF(反射), BTDF(折射), BSDF(散射), BSSRDF(次表面散射)等几种双向分布函数的一个统一表示 BSDF = BRDF + BTDF BSSRDF: 相比与BRDF可以指定不同光线入射位置和出射位置 BSDF, BTDF, BSSRDF用于表示透明材质和次表面散射材质    漫反射BRDF(Diffuse BRDF)   传统型:\n Lambert    基于物理模型:\n Oren Nayar Simplified Oren-Nayar Disney Diffuse Renormalized Disney Diffuse Gotanda Diffuse PBR diffuse for GGX+Simth MultiScattering Diffuse    Disney Principled BRDF   着色模型是艺术导向(Art Directable), 不一定要完全物理正确(physically correct)\n  核心理念:\n 应使用直观的参数, 非物理类晦涩参数 参数尽可能少 参数合理范围在0-1 允许参数在有意义时超出正常的合理范围 所有参数组合应尽可能健壮和合理    BRDF参数:\n baseColor(基础色): 表面颜色, 通常由纹理提供 subsurface(次表面): 使用次表面近似控制漫反射形状 metallic(金属度): 金属(0=电介质, 1=金属), 两种不同模型间的线性混合, 金属模型无漫反射 specular(镜面反射强度): 入射镜面反射量, 用于取代折射率 specularTint(镜面反射颜色): 对美术控制的让步, 用于基础色(base color)的入射镜面反射进行颜色控制, 掠射镜面反射仍然非彩色 roughness(粗糙度): 表面粗糙度, 控制漫反射和镜面反射 anisotropic(各向异性强度): 各向异性强度, 用于控制镜面反射高光的纵横比(0同向异性, 1各向异性) sheen(光泽度): 额外的掠射分量(gazing component), 主要用于布料 sheenTint(光泽颜色): 对sheen的颜色控制 clearcoat(清漆强度): 有特殊用途的第二个镜面波瓣(specular lobe) clearcoarGloss(清漆光泽度): 控制透明图层光泽度, 0 = \u0026ldquo;缎面(satin)\u0026ldquo;外观, 1 = \u0026ldquo;光泽(gloss)\u0026ldquo;外观    镜面反射BRDF(Specular BRDF)  目前业界主流基于物理的Specular BRDF: Microfacet Cook-Torrance BRDF  Cook-Torrance BRDF 模型   由漫反射(Lambertian)和镜面反射(cook-torrance)组成\n  Lambertian: c / π\n π用于对漫反射光进行标准化 足够应付大多数实时渲染    cook-torrance: DFG / 4(ωo⋅n)(ωi⋅n)\n Specular D: 法线/镜面分布函数, 估算受到表面粗糙程度情况下, 取方向与半程向量一致的微平面数量, 用来估算微平面的主要函数 Specular F: 菲涅耳方程, 不同的表面角下表面所反射的光线所占的比率 Specular G: 几何函数, 描述了微平面自成阴影的属性, 当一个平面比较粗糙, 微平面可能挡住其他微平面减少反射的光线    UE4使用的函数:\n Specular D: Trowbridge-Reitz GGX Specular F: Fresnel-Shilick Approximation Specular G: Smith\u0026rsquo;s Schlick-GGX    法线分布函数( Normal Distribution Function )  统计学上近似表示半程向量h取向一致的微平面比率 输入: 材料的粗糙程度 Trowbridge-Reitz GGX in GLSL:  1 2 3 4 5 6 7 8 9 10 11 12  float D_GGX_TR(vec3 N, vec3 H, float a){ float a2 = a * a; float NdotH = max(dot(N, H), 0.0); float NdotH2 = NdotH * NdotH; float nom = a2; float denom = (NdotH2 * (a2 - 1.0) + 1.0); denom = PI * denom * denom; return nom / denom; }   几何函数 (Geometry Function)  从统计学上近似求得微平面间互相遮蔽的比率, 相互遮蔽会损耗光线的能量 输入: 材料的粗糙程度, 粗糙度较高的表面, 其平面间的相互遮蔽概率就越高 使用的几何函数: Schlick-GGX: (GGX, Schlick-Beckmann) 为了有效估算几何部分, 需要考虑:  观察方向(Geometry Obstruction) 光线方向向量(几何阴影(Geometry Shadowing))   使用史密斯法(Smith's method)包含观察方向和光线方向向量 Schlick-GGX in GLSL:  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  float GeometrySchlickGGX(float NdotV, float k){ float nom = NdotV; float denom = NdotV * (1.0 - k) + k; return nom / denom; } float GeometrySmith(vec3 N, vec3 V, vec3 L, float k){ float NdotV = max(dot(N, V), 0.0); float NdotL = max(dot(N, L), 0.0); float ggx1 = GeometrySchlickGGX(NdotV, k); float ggx2 = GeometrySchlickGGX(NdotL, k); return ggx1 * ggx2; }   菲涅尔方程 (Fresnel Requation)   描述被反射的光线对比光线被折射部分所占的比率, 这个比率会随着观察角度不同而不同\n  当光线碰撞到一个表面时, 菲捏尔方程会根据观察角度求得被反射光线的占比, 根据能量守恒原则, 可以直接得出光线被折射的部分以及剩余能量\n  折射指数(IOR, Indices of Refraction): 光在传播到两种不同介质交界处(穿过)时, 原始光波和新的光波的相速度(Phase Velocity)的比率\n  垂直观察物体时该表面只有基础反射率(Base Reflectivity), 利用折射指数计算得出\n  当视线法线夹角增大时反射性会增大, 90度理论上能完全反射光线\n  使用Freshnel-Schlick近似法求得近似解 ( 菲涅尔原始方程较复杂 )\n  仅对非金属表面(介电质)有效, 对于导体(Conductor)表面, 使用IOR计算F0不能得出正确的结论, 需要分别使用不同的菲涅尔方程, 很麻烦\n  统一金属和非金属公式: 通常预先计算出F0, 然后基于相应观察角的Freshnel-Schlick近似对这个值进行插值\n  F0规律: 非金属通常不会高于0.17, 导体材质大多在0.7-1.0\n  Freshel Schlick in GLSL:\n  1 2 3 4 5 6 7  // calc F0 // vec3 F0 = vec3(0.04); // F0 = mix(F0, surfaceColor.rgb, metalness);  vec3 freshnel Schlick(float cosTheta, vec3 F0){ return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0); }   ","description":"PBR 学习记录 -- 理论基础","id":11,"section":"posts","tags":["CG"],"title":"PBR笔记 - 理论基础","uri":"http://npchitman.github.io/posts/pbr-theory/"},{"content":"渲染管线主要功能是对给定虚拟相机, 三维物体, 光源, 照明模式, 纹理等条件情况下, 生成一副二维图像的过程\n图形渲染管线工作流程 应用阶段(Application)  开发者通过程序对图元数据进行配置和调控 由于可以对该阶段进行完全控制, 可以通过更改实现方法来改变性能 通常该阶段在几个并行处理器上执行, 称为超量体系(superscalar)结构 通常实现的方法有: 碰撞检测, 加速算法, 输入检测, 动画, 力反馈, 纹理动画, 变换仿真, 几何变形, 和一些不在其他阶段执行的算法 (如层次视锥裁剪等加速算法) 该阶段将摄像机位置, 光照和模型的图元数据输出到几何阶段  几何阶段(Geometry)   模型视点变换(Model to View Transform):\n 模型变换(model transform): 从model space到world space, 转到适合模型渲染的空间中 视图变换(view transform): 转换到观察空间(view space), 将相机放在原点, 进行视点校准(朝向z轴负方向, y轴指向上方, x轴指向右边)    顶点着色(Vertex Shadering): 主要确定模型顶点处材质的光照效果\n 对物体的外观进行建模, 得到每个对象的材质, 照射在对象光源效果的一些描述 着色(shading): 确定材质上的光照效果, 过程涉及在对象上各个点计算着色方程(shading equation) 可以在顶点处存储各种材料数据(颜色, 向量, 纹理坐标, 法线, 颜色坐标或计算着色方程所需的其他信息) 顶点着色的结果计算完成后作为光栅化阶段的输入进行处理    投影(Projection):\n 将视体变换到一个单位立方体内(规范立方体(Canonical View Volume, CVV, 对角顶点为(-1, -1, -1), (1, 1, 1)) 主要有两种投影方法: 正交投影(orthographic/parallel projection), 透视投影(perspective projection) 完成投影后, z坐标将不会保存于得到的图片中, 实现了从3d转为2d    裁剪(Clipping): 去除相对于屏幕外的物体\n 只有当图元处于CVV中才需要将其发送到光栅化阶段 图元相对于CVV分三种情况: 完全位于内部(不处理), 部分位于内部(裁剪处理), 完全位于外部(直接丢弃)    屏幕映射(Screen mapping): 将之前步骤得到的坐标映射到对应的屏幕坐标系\n 首先进行平移, 再缩放 映射过程中z坐标不受影响 新的x, y坐标称为屏幕坐标系, 与z坐标一起进入光栅化阶段    光栅化(Rasterization)   从二维顶点的屏幕空间(包含深度值, 及相关着色信息), 到屏幕上的像素转换\n  由几何阶段确定屏幕上的顶点, 颜色, 纹理坐标后, 给每个像素(Pixel)正确配色, 绘制整幅图像\n  光栅化步骤   三角形设定(Triangle Setup)\n 计算三角形表面差异和其他相关数据 该数据主要用于扫描转换(scan conversion), 和由几何阶段处理的各种着色数据插值操作所用 该过程在专门的硬件上执行    三角形遍历/扫描转换(Triangle Traversal/scan conversion)\n 进行逐像素检查操作, 即检查哪些采样点(像素)在三角形中 对于有三角形部分重合的像素, 在重合部分生成片段(fragment) 每个三角形片段属性(片段的深度, 着色数据)均由其三个顶点插值生成    像素着色(Pixel Shading)\n 进行逐像素着色, 如纹理贴图(Texturing)操作 使用插值的着色数据作为输入, 输出一种或多种颜色信息到下一阶段 在可编程GPU进行    融合(Merging)\n 融合的主要任务是合成当前存储于缓冲器中的片段颜色(上个阶段产生), 非完全可编程, 但高度可配置 帧缓冲(frame buffer): 通常包含一个系统所具有的所有缓冲器(或是color buffer和z-buffer的组合) 颜色缓冲器: 颜色(RGB)的矩阵列, 每个像素的信息都存在颜色缓冲器中 深度缓冲(z-buffer): 负责可见性的处理, 通常通过z-buffer来实现 alpha通道(alpha channel): 和颜色缓冲器计算每个像素的不透明值, 在深度测试前传入片段中运行, 通常用于不影响深度缓冲的全透明片段处理 模板缓冲(stencil buffer): 记录所呈现图元位置的离屏缓存, 每个像素通常占用8位, 用于进行一些特效制作 累计缓冲(accumulation buffer): 用一组操作符对图像进行累积, 用于产生动态模糊(motion blur), 景深(depth of field), 后处理反走样(post-process anti-aliasing), 软阴影(soft shadows)等;    双缓冲(double buffering):\n 用于避免观察者感知到图元处理发送到屏幕的过程 屏幕绘制在后置缓冲器(backbuffer)中离屏进行 后置缓冲器不断与用于屏幕显示的前置缓冲内容进行交换(不影响显示时)    GPU渲染管线工作流程 现代编程语言  现代着色阶段(Shader model 4.0, DirectX 10及以后)使用通用着色核心(common-shader core), 表明顶点, 片段, 几何着色器共享一套编程模型 目前着色语言都是C-like, 如GLSL, CG, HLSL 被编译成独立于机器语言的汇编语言IL, 通常在驱动中转化成实际机器语言, 可以兼容不同硬件实现 IL可以理解成定义一个着色语言编译器的虚拟机, 处理多种类型寄存器和数据源, 预编一系列指令处理器 很多图形操作使用短矢量(最高四位), 处理器拥有4路SIMD(single-instruction multiple-data, 单指令多数据)兼容性 每个寄存器包含四个独立的值, 32位单精度浮点的标量和矢量是其基本数据类型, 也支持结构体, 数组和矩阵  矢量: 位置(xyzw), 法线, 矩阵行, 颜色(rgba), 纹理坐标(uvwq) 标量: 计数器, 索引, 位掩码    实现步骤概述  顶点着色前进行输入装配(Input Assembler)阶段, 将一些数据流组织在一起, 发送到管线  GPU实现了几何和光栅化概念管线阶段, 步骤如下:\n顶点着色器(Vertex Shader): 完全可编程  顶点属性包括位置, 颜色, 法线, 纹理坐标 对每个顶点属性进行变换, 变形等操作, 提供修改/创建/忽略顶点相关属性的功能 不能创建和删除顶点, 一个顶点的结果不能传递到另一个顶点 每个顶点独立处理, 使得GPU上着色器处理器可以并行应用到传入的顶点流上 可以在这里进行光照计算, 由于精度不高通常在片段着色器中计算 该阶段顶点坐标必须完成顶点从模型空间转换到齐次裁剪空间(世界, 观察, 裁剪) 流输出(Stream output): Shader Model4.0以上支持, 顶点着色器除了将处理后的数据发送到光栅化阶段, 还可以输出到流(有序数组), 输出到流的数据可以通过管线回传, 允许迭代处理, 是和模拟流动的水和其他特效  细面曲分 (Teselation Shader): 可选  利用镶嵌化处理技术对三角面进行细分, 以此来增加三角面的数量 借助曲面细分的技术实现LOD机制 组成:  外壳着色器(Hull Shader): 可编程 镶嵌器(Tessellator): 由硬件管理 域着色器(Domain Shader): 可编程    几何着色器(Geometry Shader): 可选, 完全可编程  Shader Model 3.0以上支持 主要对输入图元(单个对象及相关的顶点)进行操作 允许GPU高效创建和销毁几何图元:  几何增长: 改变新传递的图元的拓扑结构 接受任意拓扑类型的图元, 输出点, 折线(line strip), 三角形条(triangle strips)   常见应用:  元球的等值曲面细分(metaball isosurface tessellation) 线段细分的分形(fractal subdivision of line segments) 布料模拟等    功能阶段  裁剪(Clipping): 可配置  可选运行的裁剪方式, 添加自定义的裁剪面   屏幕映射(Screen Mapping): 完全固定 三角形设定(Triangle Setup): 完全固定 三角形遍历(Triangle Traversal): 完全固定  像素/片段着色器(Pixel/Fragment Shader): 可编程  该着色器主要进行像素/片元的处理, 在每个片段上执行着色方程 常用来处理场景光照及相关(如阴影)的效果处理, 如凹凸纹理映射和调色 着色器调用的像素并非和屏幕像素一一对应, 如计算被遮挡的物体的片段 该着色器通常在最终合并阶段设置片段颜色进行合并, 深度值也可以在该着色器修改 SM4.0中共有16个4维向量可以从顶点着色器传到像素着色器, 使用几何着色器时增加到32个  合并阶段(Merging): 可配置  将像素着色器中生成的各个片段的深度和颜色与帧缓冲结合在一起 除了进行合并操作, 还可以进行相关缓存的处理(z-buffer, Stencil等), 透明处理(Transparency), 混合(Blending), 合成(Compositing) 该阶段不可编程, 但是高度可配置, 可以设置颜色混合来执行大量不同操作:  Alpha值的乘法, 加法, 减法的组合, 根据片段的Alpha值进行混合, 用来产生半透明的效果 最大值, 最小值, 按位逻辑运算   半透明的物体需要遵循画家算法进行绘制, 或使用顺序无关的半透明渲染技术(OIT)技术  ","description":"渲染管线流程","id":12,"section":"posts","tags":["cg"],"title":"渲染管线流程","uri":"http://npchitman.github.io/posts/render-pipline/"},{"content":"效果预览    Info Preview          介绍  对纯键盘操作进行优化 其他的发行版未测试, 理论上也适用 具体的系统环境参考图1(Info)  安装方法 执行部署脚本 注: 脚本将所有的配置部署到相应的目录下, 为了安全性, 若文件存在则不会覆盖,\n若要使用安装脚本, 请备份好自己的配置再将其从相应的目录删除\n1 2 3 4 5  git clone https://github.com/npchitman/dot_files cd dot_files sh put.sh   安装字体  Fantasque: 非常好看的编程用字体 Font-Awesome: 图标, 可在这里查找  使用方法 快捷键  全部快捷键在 i3config 配置里, 举出一些例子  快捷菜单    按键 说明     Super + d 快捷启动应用   Super + Shift + d 应用菜单   Super + Shift + w 快捷启动站点   Super + shift + e 电源选项    音频控制  需要 playerctl 支持,\nspotify 下完美使用, 其他自行测试     按键 说明     Super + Shift + n/m 播放上一首/下一首曲子   Super + Alt + p 暂停/继续播放   Super + Alt + k/j 音量增加/减少   Super + Alt + m 静音/取消静音    其他    按键 说明     Super + Alt + w 随机壁纸与相应配色, 需要 pywal 支持   Super + a 快速截图, 需要 scort 支持    配置文件包含的应用 - config    应用名 说明     compton 独立合成管理器, 为 i3 提供淡入淡出, 阴影等效果   dunst 通知窗口   i3 i3 桌面配置   polybar 系统状态栏, 若要使用请参考 wiki   ranger tui 文件浏览器, 支持图片预览等功能   rofi 包含程序启动器, 电源菜单, 网站快捷打开菜单   termite 模拟终端   tilda 下拉式模拟终端   vimiv 类 vim 操作的图片浏览工具    - emacs   基于 redguardtoo/emacs.d\n的配置, 请参考文档\n  custom.el: 请参考 overide default setup\n  - nvim  使用 thinkvim 的配置 thinkvim.d: 参考 User Custom  快捷键绑定  下面是个人自定义快捷键, 关于 thinkvim 默认的快捷键参考 leaderkey.vim 和 motion.vim \u0026lt;LocalLeader\u0026gt;为分号;     快捷键 说明     H/L 移动到改行句首/尾   Ctrl g 映射为Esc键   \u0026lt;LocalLeader\u0026gt; cc/cu 注释/取消注释   \u0026lt;LocalLeader\u0026gt;\u0026lt;LocalLeader\u0026gt; k/j 向上/下快速跳转光标   \u0026lt;LocalLeader\u0026gt; q 退出vim    - xorg X系统相关配置, 下面给出相关 wiki\n  Xresources\n  Xinitrc\n  Xprofile\n  - zsh zsh 相关配置, 参考 ohmyzsh\n zprofile zshrc  ","description":"arch linux, i3wm","id":13,"section":"posts","tags":["linux"],"title":"Linux Ricing 1.0","uri":"http://npchitman.github.io/posts/linux_ricing/"}]